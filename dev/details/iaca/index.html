<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>iACA · AdaptiveCrossApproximation.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="AdaptiveCrossApproximation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AdaptiveCrossApproximation.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/manual/">General Usage</a></li><li><a class="tocitem" href="../../manual/examples/">Application Examples</a></li></ul></li><li><span class="tocitem">Further Details</span><ul><li><a class="tocitem" href="../aca/">ACA</a></li><li class="is-active"><a class="tocitem" href>iACA</a><ul class="internal"><li><a class="tocitem" href="#Motivation"><span>Motivation</span></a></li><li><a class="tocitem" href="#The-Challenge"><span>The Challenge</span></a></li><li><a class="tocitem" href="#Geometric-Pivoting"><span>Geometric Pivoting</span></a></li><li><a class="tocitem" href="#Algorithm-Variants"><span>Algorithm Variants</span></a></li><li><a class="tocitem" href="#Tree-Based-Acceleration"><span>Tree-Based Acceleration</span></a></li><li><a class="tocitem" href="#Convergence-Criteria"><span>Convergence Criteria</span></a></li><li><a class="tocitem" href="#Performance-Characteristics"><span>Performance Characteristics</span></a></li><li><a class="tocitem" href="#Use-Cases"><span>Use Cases</span></a></li><li><a class="tocitem" href="#Integration-with-Hierarchical-Matrices"><span>Integration with Hierarchical Matrices</span></a></li></ul></li><li><a class="tocitem" href="../pivoting/">Pivoting Strategies</a></li><li><a class="tocitem" href="../convergence/">Convergence Criteria</a></li></ul></li><li><a class="tocitem" href="../../contributing/">Contributing</a></li><li><a class="tocitem" href="../../apiref/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Further Details</a></li><li class="is-active"><a href>iACA</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>iACA</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/main/docs/src/details/iaca.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Incomplete-Adaptive-Cross-Approximation"><a class="docs-heading-anchor" href="#Incomplete-Adaptive-Cross-Approximation">Incomplete Adaptive Cross Approximation</a><a id="Incomplete-Adaptive-Cross-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Incomplete-Adaptive-Cross-Approximation" title="Permalink"></a></h1><h2 id="Motivation"><a class="docs-heading-anchor" href="#Motivation">Motivation</a><a id="Motivation-1"></a><a class="docs-heading-anchor-permalink" href="#Motivation" title="Permalink"></a></h2><p>Incomplete ACA (iACA) addresses a fundamental limitation of standard ACA: the requirement to access individual matrix entries. In many applications, particularly hierarchical matrix compression, we need to compress matrix blocks where:</p><ol><li><strong>No entry access</strong>: Individual entries <span>$A_{ij}$</span> cannot be efficiently computed</li><li><strong>Geometric information available</strong>: Point positions or spatial structure is known</li><li><strong>Batch operations only</strong>: Can extract full rows/columns but not single entries</li></ol><p>iACA solves this by using <strong>geometric pivoting strategies</strong> that select pivots based on spatial distribution rather than matrix values.</p><h2 id="The-Challenge"><a class="docs-heading-anchor" href="#The-Challenge">The Challenge</a><a id="The-Challenge-1"></a><a class="docs-heading-anchor-permalink" href="#The-Challenge" title="Permalink"></a></h2><p>Standard ACA requires value-based pivoting to select the next pivot:</p><p class="math-container">\[i_{k+1} = \arg\max_i |r_{ij_k}|\]</p><p>where <span>$r_{ij_k}$</span> is a residual entry. Computing this maximum requires:</p><ul><li>Access to individual residual entries</li><li>Full deflation: <span>$r_{ij} = A_{ij} - \sum_{\ell=1}^k u_{\ell i} v_{\ell j}$</span></li></ul><p>For kernel matrices in hierarchical formats:</p><ul><li><p class="math-container">\[A_{ij} = K(x_i, y_j)\]</p>requires expensive kernel evaluation</li><li>Deflation requires <span>$O(k)$</span> evaluations per entry</li><li>Examining all entries for maximum is prohibitive</li></ul><h2 id="Geometric-Pivoting"><a class="docs-heading-anchor" href="#Geometric-Pivoting">Geometric Pivoting</a><a id="Geometric-Pivoting-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Pivoting" title="Permalink"></a></h2><p>Instead of examining matrix values, iACA selects pivots based on geometric criteria applied to the point sets <span>$X = \{x_1, \ldots, x_m\}$</span> and <span>$Y = \{y_1, \ldots, y_n\}$</span>.</p><h3 id="Fill-Distance-Strategy"><a class="docs-heading-anchor" href="#Fill-Distance-Strategy">Fill Distance Strategy</a><a id="Fill-Distance-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Fill-Distance-Strategy" title="Permalink"></a></h3><p>Select points maximally separated from already chosen points:</p><p class="math-container">\[x_{k+1} = \arg\max_{x \in X \setminus S_k} \min_{y \in S_k} \|x - y\|\]</p><p>This ensures good spatial coverage without matrix access.</p><h3 id="Leja-Points"><a class="docs-heading-anchor" href="#Leja-Points">Leja Points</a><a id="Leja-Points-1"></a><a class="docs-heading-anchor-permalink" href="#Leja-Points" title="Permalink"></a></h3><p>Select points to maximize a product criterion:</p><p class="math-container">\[x_{k+1} = \arg\max_{x \in X \setminus S_k} \prod_{i=1}^k \|x - x_i\|\]</p><p>Provides excellent distribution properties with theoretical guarantees.</p><h3 id="Mimicry-Based-Strategies"><a class="docs-heading-anchor" href="#Mimicry-Based-Strategies">Mimicry-Based Strategies</a><a id="Mimicry-Based-Strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Mimicry-Based-Strategies" title="Permalink"></a></h3><p>The most powerful approach for hierarchical matrices: <strong>reuse pivot patterns</strong> from previous compressions.</p><p><strong>Key insight</strong>: When compressing multiple matrix blocks with similar geometric structure:</p><ol><li>Compress first block using any geometric strategy</li><li>Store the selected pivot indices</li><li>Reuse these indices for subsequent similar blocks</li><li>Avoid repeated pivot selection computation</li></ol><p>This dramatically reduces overhead in hierarchical matrix construction where thousands of similar blocks must be compressed.</p><h2 id="Algorithm-Variants"><a class="docs-heading-anchor" href="#Algorithm-Variants">Algorithm Variants</a><a id="Algorithm-Variants-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm-Variants" title="Permalink"></a></h2><h3 id="Row-Matrix-Variant"><a class="docs-heading-anchor" href="#Row-Matrix-Variant">Row Matrix Variant</a><a id="Row-Matrix-Variant-1"></a><a class="docs-heading-anchor-permalink" href="#Row-Matrix-Variant" title="Permalink"></a></h3><p>For iACA with geometric row pivoting and value-based column pivoting:</p><ol><li><strong>Select row geometrically</strong>: <span>$i_k$</span> based on point positions</li><li><strong>Extract row</strong>: <span>$v_k^T = A[i_k, :]$</span> (full row extraction)</li><li><strong>Select column by value</strong>: <span>$j_k = \arg\max_j |v_{kj}|$</span></li><li><strong>Extract and deflate column</strong>: <span>$\tilde{u}_k = A[:, j_k] - \sum_{\ell&lt;k} u_\ell v_{\ell j_k}$</span></li><li>Normalize and continue</li></ol><p><strong>Key property</strong>: Only full row/column extractions needed, no individual entry access.</p><h3 id="Column-Matrix-Variant"><a class="docs-heading-anchor" href="#Column-Matrix-Variant">Column Matrix Variant</a><a id="Column-Matrix-Variant-1"></a><a class="docs-heading-anchor-permalink" href="#Column-Matrix-Variant" title="Permalink"></a></h3><p>Symmetric variant starting with geometric column selection:</p><ol><li>Select column geometrically</li><li>Extract full column</li><li>Select row by maximum value</li><li>Extract and deflate row</li><li>Continue</li></ol><h3 id="Pure-Geometric-Variant"><a class="docs-heading-anchor" href="#Pure-Geometric-Variant">Pure Geometric Variant</a><a id="Pure-Geometric-Variant-1"></a><a class="docs-heading-anchor-permalink" href="#Pure-Geometric-Variant" title="Permalink"></a></h3><p>Both rows and columns selected geometrically:</p><ul><li>No matrix access for pivoting</li><li>Most efficient for hierarchical matrices</li><li>Requires good geometric strategies</li></ul><h2 id="Tree-Based-Acceleration"><a class="docs-heading-anchor" href="#Tree-Based-Acceleration">Tree-Based Acceleration</a><a id="Tree-Based-Acceleration-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Based-Acceleration" title="Permalink"></a></h2><h3 id="Brute-Force-Approach"><a class="docs-heading-anchor" href="#Brute-Force-Approach">Brute Force Approach</a><a id="Brute-Force-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#Brute-Force-Approach" title="Permalink"></a></h3><p>Computing fill distance or Leja criteria naively requires:</p><ul><li><p class="math-container">\[O(mk)\]</p>distance computations at iteration <span>$k$</span></li><li>Total <span>$O(mr^2)$</span> for rank <span>$r$</span></li></ul><p>For large point sets, this becomes expensive even though no matrix access is needed.</p><h3 id="Tree-Based-Approach"><a class="docs-heading-anchor" href="#Tree-Based-Approach">Tree-Based Approach</a><a id="Tree-Based-Approach-1"></a><a class="docs-heading-anchor-permalink" href="#Tree-Based-Approach" title="Permalink"></a></h3><p>Using spatial trees (quadtree, octree, k-d tree):</p><ol><li><strong>Preprocessing</strong>: Build tree structure <span>$O(m \log m)$</span></li><li><strong>Pivot selection</strong>: Use tree to find next pivot in <span>$O(\log m)$</span> per iteration</li><li><strong>Total cost</strong>: <span>$O(r \log m)$</span> instead of <span>$O(mr^2)$</span></li></ol><p>The <code>TreeMimicryPivoting</code> strategy implements this efficiently, navigating the tree to quickly identify optimal geometric pivots.</p><p><strong>Additional benefits</strong>:</p><ul><li>Natural hierarchical structure for matrix blocks</li><li>Can share tree across multiple compressions</li><li>Enables efficient mimicry by tree traversal patterns</li></ul><h2 id="Convergence-Criteria"><a class="docs-heading-anchor" href="#Convergence-Criteria">Convergence Criteria</a><a id="Convergence-Criteria-1"></a><a class="docs-heading-anchor-permalink" href="#Convergence-Criteria" title="Permalink"></a></h2><p>Standard convergence criteria require inner products:</p><p class="math-container">\[\|UV^T\|_F^2 = \sum_{i,j} \langle u_i, u_j \rangle \langle v_i, v_j \rangle\]</p><p>iACA cannot compute these without entry access. Instead, use <strong>simplified criteria</strong>:</p><h3 id="Moving-Average-Norm"><a class="docs-heading-anchor" href="#Moving-Average-Norm">Moving Average Norm</a><a id="Moving-Average-Norm-1"></a><a class="docs-heading-anchor-permalink" href="#Moving-Average-Norm" title="Permalink"></a></h3><p>Track the moving average:</p><p class="math-container">\[\bar{n}_k = \frac{1}{k} \sum_{i=1}^k \|u_i\| \|v_i\|\]</p><p>Terminate when:</p><p class="math-container">\[\|u_k\| \|v_k\| &lt; \text{tol} \cdot \bar{n}_k\]</p><p>This requires only row/column norms, not full inner products.</p><h3 id="Fixed-Rank"><a class="docs-heading-anchor" href="#Fixed-Rank">Fixed Rank</a><a id="Fixed-Rank-1"></a><a class="docs-heading-anchor-permalink" href="#Fixed-Rank" title="Permalink"></a></h3><p>Simply compress to a predetermined rank based on a priori estimates or hierarchical matrix theory.</p><h2 id="Performance-Characteristics"><a class="docs-heading-anchor" href="#Performance-Characteristics">Performance Characteristics</a><a id="Performance-Characteristics-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Characteristics" title="Permalink"></a></h2><h3 id="Computational-Cost"><a class="docs-heading-anchor" href="#Computational-Cost">Computational Cost</a><a id="Computational-Cost-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Cost" title="Permalink"></a></h3><p>For rank-<span>$r$</span> compression of <span>$m \times n$</span> matrix:</p><ul><li><strong>Matrix access</strong>: <span>$r$</span> rows + <span>$r$</span> columns = <span>$O(r(m+n))$</span> entries</li><li><strong>Pivot selection</strong>: <span>$O(r \log m)$</span> with trees vs <span>$O(mr^2)$</span> brute force</li><li><strong>Deflation</strong>: <span>$O(r^2(m+n))$</span> same as standard ACA</li></ul><h3 id="Memory"><a class="docs-heading-anchor" href="#Memory">Memory</a><a id="Memory-1"></a><a class="docs-heading-anchor-permalink" href="#Memory" title="Permalink"></a></h3><ul><li><strong>Point coordinates</strong>: <span>$O(m+n)$</span> spatial data</li><li><strong>Tree structure</strong>: <span>$O(m+n)$</span> for spatial tree</li><li><strong>Buffers</strong>: Same as standard ACA</li></ul><h3 id="Accuracy"><a class="docs-heading-anchor" href="#Accuracy">Accuracy</a><a id="Accuracy-1"></a><a class="docs-heading-anchor-permalink" href="#Accuracy" title="Permalink"></a></h3><p>Geometric pivoting generally achieves similar accuracy to value-based pivoting when:</p><ul><li>Kernel is smooth (exponentially decaying in distance)</li><li>Point sets are well-distributed</li><li>Separation ratio is favorable</li></ul><p>For rough kernels or poorly distributed points, value-based pivoting may be superior.</p><h2 id="Use-Cases"><a class="docs-heading-anchor" href="#Use-Cases">Use Cases</a><a id="Use-Cases-1"></a><a class="docs-heading-anchor-permalink" href="#Use-Cases" title="Permalink"></a></h2><p><strong>Use iACA when:</strong></p><ul><li>Working with hierarchical matrix formats (<span>$\mathcal{H}$</span>, <span>$\mathcal{H}^2$</span>)</li><li>Individual kernel evaluations are expensive</li><li>Geometric information is naturally available</li><li>Many similar blocks need compression (use mimicry)</li></ul><p><strong>Use standard ACA when:</strong></p><ul><li>Matrix entries are cheap to access</li><li>No geometric structure available</li><li>Maximum accuracy is critical</li><li>Working with single matrix compression</li></ul><h2 id="Integration-with-Hierarchical-Matrices"><a class="docs-heading-anchor" href="#Integration-with-Hierarchical-Matrices">Integration with Hierarchical Matrices</a><a id="Integration-with-Hierarchical-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Integration-with-Hierarchical-Matrices" title="Permalink"></a></h2><p>iACA is the natural compression method for hierarchical matrices:</p><ol><li><strong>Block clustering</strong>: Partition points into spatial clusters</li><li><strong>Admissibility</strong>: Identify far-field block pairs</li><li><strong>Compression</strong>: Use iACA with geometric pivoting for each admissible block</li><li><strong>Mimicry</strong>: Share pivot patterns among geometrically similar blocks</li><li><strong>Tree structure</strong>: Use same spatial tree for all operations</li></ol><p>This workflow enables:</p><ul><li><p class="math-container">\[O(n \log n)\]</p>or <span>$O(n)$</span> storage for <span>$n \times n$</span> matrices</li><li><p class="math-container">\[O(n \log n)\]</p>or <span>$O(n)$</span> matrix-vector products</li><li>Efficient assembly without forming full matrix</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../aca/">« ACA</a><a class="docs-footer-nextpage" href="../pivoting/">Pivoting Strategies »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 7 November 2025 15:09">Friday 7 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
