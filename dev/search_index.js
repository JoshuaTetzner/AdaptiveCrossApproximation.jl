var documenterSearchIndex = {"docs":
[{"location":"apiref/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"apiref/","page":"API Reference","title":"API Reference","text":"Modules = [AdaptiveCrossApproximation]","category":"page"},{"location":"apiref/#AdaptiveCrossApproximation.ACA","page":"API Reference","title":"AdaptiveCrossApproximation.ACA","text":"ACA{RowPivType,ColPivType,ConvCritType}\n\nAdaptive Cross Approximation (ACA) compressor for low-rank matrix approximation.\n\nComputes M ≈ U * V by iteratively selecting rows and columns (pivots) until a convergence criterion is met. The algorithm starts with row, samples it to select a column pivot, then alternates between row and column selection.\n\nFields\n\nrowpivoting::RowPivType: Strategy for selecting row pivots\ncolumnpivoting::ColPivType: Strategy for selecting column pivots\nconvergence::ConvCritType: Convergence criterion to stop iterations\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.ACA-Tuple{AbstractArray{Int64}, AbstractArray{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.ACA","text":"(aca::ACA)(rowidcs::AbstractArray{Int}, colidcs::AbstractArray{Int})\n\nCreate a specialized ACA instance for a submatrix defined by index sets.\n\nInitializes pivoting functors with the provided row and column indices. Used internally for hierarchical matrix compression.\n\nArguments\n\nrowidcs: Row indices of the submatrix\ncolidcs: Column indices of the submatrix\n\nReturns\n\nNew ACA instance with initialized pivoting state for the given indices.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACA-Tuple{}","page":"API Reference","title":"AdaptiveCrossApproximation.ACA","text":"ACA(; rowpivoting=MaximumValue(), columnpivoting=MaximumValue(),\n      convergence=FNormEstimator(1e-4))\n\nConstruct an ACA compressor with keyword arguments.\n\nKeyword Arguments\n\nrowpivoting: Row pivot selection strategy (default: MaximumValue())\ncolumnpivoting: Column pivot selection strategy (default: MaximumValue())\nconvergence: Convergence criterion (default: FNormEstimator(1e-4))\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACA-Union{Tuple{C}, Tuple{CP}, Tuple{RP}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RP<:AdaptiveCrossApproximation.PivStrat, CP<:AdaptiveCrossApproximation.PivStrat, C<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.ACA","text":"(aca::ACA{P,P,C})(A, colbuffer, rowbuffer, maxrank; kwargs...)\n\nConvenience method that initializes pivoting functors when using uniform strategies.\n\nDelegates to the main computational routine after creating index-specialized functors. Only available when both pivoting strategies are of the same stateless type P <: PivStrat.\n\nSee the main (aca::ACA)(A, colbuffer, rowbuffer, rows, cols, rowidcs, colidcs, maxrank) method for detailed argument documentation.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACA-Union{Tuple{T}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, T, T, T, T, Int64}} where {K, T<:Vector{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.ACA","text":"(aca::ACA)(A, colbuffer, rowbuffer, rows, cols, rowidcs, colidcs, maxrank)\n\nCompute ACA approximation with preallocated buffers (main computational routine).\n\nFills colbuffer and rowbuffer with low-rank factors U and V such that A[rowidcs, colidcs] ≈ U * V. Uses deflation to ensure orthogonality of pivots.\n\nArguments\n\nA: Matrix or matrix-like object (must support nextrc! interface)\ncolbuffer::AbstractMatrix{K}: Buffer for U factors, size (length(rowidcs), maxrank)\nrowbuffer::AbstractMatrix{K}: Buffer for V factors, size (maxrank, length(colidcs))\nrows::Vector{Int}: Storage for selected row indices\ncols::Vector{Int}: Storage for selected column indices\nrowidcs::Vector{Int}: Global row indices of the block to compress\ncolidcs::Vector{Int}: Global column indices of the block to compress\nmaxrank::Int: Maximum number of pivots (hard limit on rank)\n\nReturns\n\nnpivot::Int: Number of pivots computed (≤ maxrank). The approximation is A[rowidcs, colidcs] ≈ colbuffer[:, 1:npivot] * rowbuffer[1:npivot, :]\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACAᵀ","page":"API Reference","title":"AdaptiveCrossApproximation.ACAᵀ","text":"ACAᵀ{RowPivType,ColPivType,ConvCritType}\n\nColumn-first variant of adaptive cross approximation. Starts by selecting columns first, then rows. Dual of standard ACA.\n\nFields\n\nrowpivoting::RowPivType: Strategy for selecting row pivots\ncolumnpivoting::ColPivType: Strategy for selecting column pivots\nconvergence::ConvCritType: Convergence criterion\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.ACAᵀ-Tuple{AbstractArray{Int64}, AbstractArray{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.ACAᵀ","text":"(aca::ACAᵀ)(rowidcs::AbstractArray{Int}, colidcs::AbstractArray{Int})\n\nInitialize ACAᵀ functor with index sets. Creates functors for pivoting strategies bound to specific index ranges.\n\nArguments\n\nrowidcs::AbstractArray{Int}: Row indices for this compression\ncolidcs::AbstractArray{Int}: Column indices for this compression\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACAᵀ-Tuple{}","page":"API Reference","title":"AdaptiveCrossApproximation.ACAᵀ","text":"ACAᵀ(; rowpivoting=MaximumValue(), columnpivoting=MaximumValue(), convergence=FNormEstimator(1e-4))\n\nConstruct column-first ACA compressor with specified strategies.\n\nArguments\n\nrowpivoting: Row pivoting strategy (default: MaximumValue())\ncolumnpivoting: Column pivoting strategy (default: MaximumValue())\nconvergence: Convergence criterion (default: FNormEstimator(1e-4))\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACAᵀ-Union{Tuple{C}, Tuple{P}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, P<:AdaptiveCrossApproximation.PivStrat, C<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.ACAᵀ","text":"(aca::ACAᵀ{P,P,C})(A, colbuffer, rowbuffer, maxrank; kwargs...)\n\nConvenience method that initializes pivoting functors when using uniform strategies.\n\nDelegates to the main computational routine after creating index-specialized functors. Only available when both pivoting strategies are of the same stateless type P <: PivStrat.\n\nSee the main (aca::ACAᵀ)(A, colbuffer, rowbuffer, rows, cols, rowidcs, colidcs, maxrank) method for detailed argument documentation.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ACAᵀ-Union{Tuple{T}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, T, T, T, T, Int64}} where {K, T<:Vector{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.ACAᵀ","text":"(aca::ACAᵀ)(A, colbuffer, rowbuffer, maxrank; rows, cols, rowidcs, colidcs)\n\nPerform column-first ACA compression. Computes low-rank approximation A ≈ colbuffer * rowbuffer by iteratively selecting columns then rows.\n\nArguments\n\nA: Matrix to compress\ncolbuffer::AbstractMatrix{K}: Pre-allocated column storage (nrows × maxrank)\nrowbuffer::AbstractMatrix{K}: Pre-allocated row storage (maxrank × ncols)\nmaxrank::Int: Maximum number of pivots\nrows: Selected row indices (optional, pre-allocated)\ncols: Selected column indices (optional, pre-allocated)\nrowidcs: Active row index range (optional)\ncolidcs: Active column index range (optional)\n\nReturns\n\nnpivot::Int: Number of pivots computed\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedConvCrit","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedConvCrit","text":"CombinedConvCrit\n\nComposite convergence criterion combining multiple criteria. Converges when any constituent criterion is satisfied.\n\nFields\n\ncrits::Vector{ConvCrit}: Vector of convergence criteria to combine\nisconverged::Vector{Bool}: Convergence status for each criterion\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedConvCrit-Tuple{AbstractMatrix, AbstractArray{Int64}, AbstractArray{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedConvCrit","text":"(convcrit::CombinedConvCrit)(K::AbstractMatrix, rowidcs, colidcs)\n\nInitialize combined criterion functors. Handles special initialization for sampling-based criteria.\n\nArguments\n\nK::AbstractMatrix: Matrix to compress\nrowidcs::AbstractArray{Int}: Active row indices\ncolidcs::AbstractArray{Int}: Active column indices\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedConvCritFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedConvCritFunctor","text":"CombinedConvCritFunctor\n\nStateful convergence criterion combining multiple criteria. Converges when all criteria are satisfied.\n\nFields\n\ncrits::Vector{ConvCritFunctor}: Vector of convergence criteria to combine\nisconverged::Vector{Bool}: Convergence status for each criterion\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedConvCritFunctor-Union{Tuple{K}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where K","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedConvCritFunctor","text":"(convcrit::CombinedConvCritFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)\n\nCheck convergence using all combined criteria. Returns when any criterion signals convergence.\n\nArguments\n\nrowbuffer::AbstractMatrix{K}: Row factor buffer\ncolbuffer::AbstractMatrix{K}: Column factor buffer\nnpivot::Int: Current pivot index\nmaxrows::Int: Number of active rows\nmaxcolumns::Int: Number of active columns\n\nReturns\n\nnpivot::Int: Final pivot count\ncontinue::Bool: Whether to continue iteration (true if any criterion satisfied)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedPivStrat","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedPivStrat","text":"CombinedPivStrat\n\nComposite pivoting strategy that switches between multiple strategies based on convergence.\n\nCombines multiple pivoting strategies with a combined convergence criterion, allowing the pivot selection method to change as different convergence criteria are satisfied. For example, can start with geometric pivoting and switch to value-based pivoting once a certain accuracy is reached.\n\nFields\n\nstrats::Vector{PivStrat}: Ordered list of pivoting strategies to use\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedPivStrat-Tuple{AdaptiveCrossApproximation.CombinedConvCritFunctor, AbstractArray{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedPivStrat","text":"(pivstrat::CombinedPivStrat)(convergence::CombinedConvCritFunctor, idcs::AbstractArray{Int})\n\nCreate a combined pivoting functor for the given index subset.\n\nInitializes all constituent strategies with the provided indices and links them to the combined convergence criterion. Handles special cases like RandomSamplingPivoting which requires the convergence criterion functor rather than indices.\n\nArguments\n\nconvergence::CombinedConvCritFunctor: Combined convergence criterion\nidcs::AbstractArray{Int}: Indices for the submatrix\n\nReturns\n\nCombinedPivStratFunctor: Initialized combined strategy with functors for all sub-strategies\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedPivStratFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedPivStratFunctor","text":"CombinedPivStratFunctor\n\nStaeful functor of composite pivoting strategy that switches between multiple strategies based on convergence.\n\nCombines multiple pivoting strategies with a combined convergence criterion, allowing the pivot selection method to change as different convergence criteria are satisfied. For example, can start with geometric pivoting and switch to value-based pivoting once a certain accuracy is reached.\n\nFields\n\nconvcrit::CombinedConvCritFunctor: Combined convergence criterion tracking which sub-criteria are met\nstrats::Vector{PivStratFunctor}: Ordered list of pivoting strategies to use\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedPivStratFunctor-Tuple{AbstractArray}","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedPivStratFunctor","text":"(pivstrat::CombinedPivStratFunctor)(rc::AbstractArray)\n\nSelect next pivot using the first strategy whose convergence criterion is met.\n\nIterates through the convergence criteria and uses the strategy corresponding to the first satisfied criterion. If no criteria are met, uses the first strategy. Automatically updates the convergence tracking state.\n\nArguments\n\nrc::AbstractArray: Row or column data for pivot selection\n\nReturns\n\nPivot index selected by the active strategy\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.CombinedPivStratFunctor-Tuple{}","page":"API Reference","title":"AdaptiveCrossApproximation.CombinedPivStratFunctor","text":"(pivstrat::CombinedPivStratFunctor)()\n\nSelect initial pivot using the first strategy.\n\nDelegates to the first strategy in the list for initial pivot selection when no data is available yet.\n\nReturns\n\nInitial pivot index from the first strategy\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ConvCrit","page":"API Reference","title":"AdaptiveCrossApproximation.ConvCrit","text":"ConvCrit\n\nAbstract base type for convergence criteria. Convergence criteria determine when to stop the ACA iteration based on approximation quality.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.ConvCritFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.ConvCritFunctor","text":"ConvCritFunctor\n\nAbstract base type for stateful convergence criterion functors. Used during compression to track convergence state across iterations.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.ConvPivStrat","page":"API Reference","title":"AdaptiveCrossApproximation.ConvPivStrat","text":"ConvPivStrat <: PivStrat\n\nAbstract type for convergence-driven pivoting strategies.\n\nThese strategies adapt their behavior based on convergence information or use randomization to improve robustness.\n\nConcrete Types\n\nRandomSampling: Random pivot selection for convergence estimation\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.ConvPivStratFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.ConvPivStratFunctor","text":"ConvPivStratFunctor <: PivStratFunctor\n\nAbstract type for stateful convergence-driven pivoting functors.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FNormEstimator","page":"API Reference","title":"AdaptiveCrossApproximation.FNormEstimator","text":"FNormEstimator{F} <: ConvCrit\n\nFrobenius norm-based convergence criterion for standard ACA.\n\nFields\n\ntol::F: Relative tolerance threshold\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FNormEstimator-Union{Tuple{}, Tuple{F}} where F","page":"API Reference","title":"AdaptiveCrossApproximation.FNormEstimator","text":"(cc::FNormEstimator{F})()\n\nInitialize FNormEstimator functor with zero accumulated norm.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FNormEstimatorFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.FNormEstimatorFunctor","text":"FNormEstimatorFunctor{F} <: ConvCritFunctor\n\nStateful Frobenius norm estimator for ACA compression. Tracks squared norm of UV factorization across iterations and stops iteration when relative error estimate falls below tolerance.\n\nFields\n\nnormUV²::F: Accumulated squared Frobenius norm of UV\ntol::F: Relative tolerance threshold\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FNormEstimatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.FNormEstimatorFunctor","text":"(convcrit::FNormEstimatorFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)\n\nCheck convergence for standard ACA using Frobenius norm estimate. Returns (npivot, continue) where continue is true if iteration should proceed.\n\nArguments\n\nrowbuffer::AbstractMatrix{K}: Row factor buffer\ncolbuffer::AbstractMatrix{K}: Column factor buffer\nnpivot::Int: Current pivot index\nmaxrows::Int: Number of active rows\nmaxcolumns::Int: Number of active columns\n\nReturns\n\nnpivot::Int: Final pivot count\ncontinue::Bool: Whether to continue iteration\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FNormExtrapolator","page":"API Reference","title":"AdaptiveCrossApproximation.FNormExtrapolator","text":"FNormExtrapolator{F} <: ConvCrit\n\nConvergence criterion using polynomial extrapolation of pivot norms. Combines norm estimation with quadratic extrapolation to predict convergence.\n\nFields\n\nestimator::Union{FNormEstimator{F},iFNormEstimator{F}}: Underlying norm estimator\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FNormExtrapolator-Tuple{F} where F","page":"API Reference","title":"AdaptiveCrossApproximation.FNormExtrapolator","text":"FNormExtrapolator(tol::F)\n\nConstruct extrapolator with Frobenius norm estimator.\n\nArguments\n\ntol::F: Convergence tolerance\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FNormExtrapolator-Union{Tuple{}, Tuple{F}} where F","page":"API Reference","title":"AdaptiveCrossApproximation.FNormExtrapolator","text":"(cc::FNormExtrapolator{F})()\n\nInitialize extrapolator functor with empty history.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FNormExtrapolatorFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.FNormExtrapolatorFunctor","text":"FNormExtrapolatorFunctor{F} <: ConvCritFunctor\n\nStateful extrapolator tracking pivot norm history. Fits quadratic polynomial to log-scaled norms for convergence prediction.\n\nFields\n\nlastnorms::Vector{F}: History of pivot norms for extrapolation\nestimator::Union{FNormEstimatorFunctor{F},iFNormEstimatorFunctor{F}}: Active estimator functor\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FNormExtrapolatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.FNormExtrapolatorFunctor","text":"(convcrit::FNormExtrapolatorFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)\n\nCheck convergence for ACA using extrapolation. Fits quadratic to log-norms and extrapolates to predict convergence.\n\nArguments\n\nrowbuffer::AbstractMatrix{K}: Row factor buffer\ncolbuffer::AbstractMatrix{K}: Column factor buffer\nnpivot::Int: Current pivot index\nmaxrows::Int: Number of active rows\nmaxcolumns::Int: Number of active columns\n\nReturns\n\nnpivot::Int: Final pivot count\ncontinue::Bool: Whether to continue iteration\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FNormExtrapolatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractVector{K}, Int64}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.FNormExtrapolatorFunctor","text":"(convcrit::FNormExtrapolatorFunctor)(rcbuffer::AbstractVector{K}, npivot::Int)\n\nCheck convergence for iACA using extrapolation. Applies extrapolation to incomplete ACA norm history.\n\nArguments\n\nrcbuffer::AbstractVector{K}: Current row or column buffer\nnpivot::Int: Current pivot index\n\nReturns\n\nnpivot::Int: Final pivot count\ncontinue::Bool: Whether to continue iteration\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FillDistance","page":"API Reference","title":"AdaptiveCrossApproximation.FillDistance","text":"FillDistance{D,F<:Real} <: GeoPivStrat\n\nGeometric pivoting strategy based on fill distance minimization.\n\nSelects pivots to minimize the fill distance, promoting well-distributed sampling in geometric space.\n\nFields\n\npos::Vector{SVector{D,F}}: Geometric positions of all points (D-dimensional)\n\nType Parameters\n\nD: Spatial dimension\nF: Floating point type for coordinates\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FillDistance-Union{Tuple{AbstractArray{Int64}}, Tuple{F}, Tuple{D}} where {D, F}","page":"API Reference","title":"AdaptiveCrossApproximation.FillDistance","text":"(pivstrat::FillDistance{D,F})(idcs::AbstractArray{Int})\n\nCreate a FillDistanceFunctor for the given index subset.\n\nInitializes the functor with positions corresponding to idcs, preparing it for pivot selection within the submatrix.\n\nArguments\n\nidcs::AbstractArray{Int}: Indices of points to consider\n\nReturns\n\nFillDistanceFunctor: Initialized functor with distance tracking\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.FillDistanceFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.FillDistanceFunctor","text":"FillDistanceFunctor{D,F<:Real} <: PivStratFunctor\n\nStateful functor for fill distance pivot selection.\n\nMaintains the minimum distances from each point to the set of selected points, updating them as new pivots are chosen.\n\nFields\n\nh::Vector{F}: Current minimum distance from each point to selected points\npos::Vector{SVector{D,F}}: Geometric positions corresponding to indices\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.FillDistanceFunctor-Union{Tuple{AbstractArray}, Tuple{F}, Tuple{D}} where {D, F}","page":"API Reference","title":"AdaptiveCrossApproximation.FillDistanceFunctor","text":"(pivstrat::FillDistanceFunctor{D,F})(::AbstractArray)\n\nSelect the next pivot minimizing the fill distance with respect to the selected points and updates the distance vector h for subsequent iterations.\n\nArguments\n\n::AbstractArray: Row/column data (unused, selection is purely geometric)\n\nReturns\n\nnextidx::Int: Index of the point maximizing fill distance\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.GeoPivStrat","page":"API Reference","title":"AdaptiveCrossApproximation.GeoPivStrat","text":"GeoPivStrat <: PivStrat\n\nAbstract type for geometric/spatial pivoting strategies.\n\nThese strategies select pivots based on spatial/geometric properties rather than matrix values. Useful when geometric information about rows/columns is available.\n\nConcrete Types\n\nFillDistance: Maximizes minimum distance to already selected points\nLeja2: Maximizes product of distances to selected points\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.GeoPivStratFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.GeoPivStratFunctor","text":"GeoPivStratFunctor <: PivStratFunctor\n\nAbstract type for stateful geometric pivoting functors.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.Leja2","page":"API Reference","title":"AdaptiveCrossApproximation.Leja2","text":"Leja2{D,F<:Real} <: GeoPivStrat\n\nGeometric pivoting strategy based on Leja points (product of distances).\n\nA modified more efficient version of the fill distance approach. This leads to well-separated point sequences. These points have been introduced as modified leja points and will, therefore, be referred to as Leja2 points within this package.\n\nFields\n\npos::Vector{SVector{D,F}}: Geometric positions of all points (D-dimensional)\n\nType Parameters\n\nD: Spatial dimension\nF: Floating point type for coordinates\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.Leja2-Union{Tuple{AbstractArray{Int64}}, Tuple{F}, Tuple{D}} where {D, F}","page":"API Reference","title":"AdaptiveCrossApproximation.Leja2","text":"(pivstrat::Leja2{D,F})(idcs::AbstractArray{Int})\n\nCreate a Leja2Functor for the given index subset.\n\nInitializes the functor with positions corresponding to idcs, preparing it for pivot selection within the submatrix.\n\nArguments\n\nidcs::AbstractArray{Int}: Indices of points to consider\n\nReturns\n\nLeja2Functor: Initialized functor with distance tracking\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.Leja2Functor","page":"API Reference","title":"AdaptiveCrossApproximation.Leja2Functor","text":"Leja2Functor{D,F<:Real} <: PivStratFunctor\n\nStateful functor for modified leja point pivot selection.\n\nMaintains minimum distances from each point to all selected points, which are updated incrementally as new pivots are chosen.\n\nFields\n\nh::Vector{F}: Current minimum distance from each point to selected points\nidcs::Vector{Int}: Indices of points being considered for selection\npos::Vector{SVector{D,F}}: Geometric positions corresponding to indices\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.Leja2Functor-Union{Tuple{AbstractArray}, Tuple{F}, Tuple{D}} where {D, F}","page":"API Reference","title":"AdaptiveCrossApproximation.Leja2Functor","text":"(pivstrat::Leja2Functor{D,F})(::AbstractArray)\n\nSelect the next pivot with maximum minimum distance to selected points.\n\nChooses the point that is farthest from the set of already selected points, then updates the distance vector for subsequent iterations.\n\nArguments\n\n::AbstractArray: Row/column data (unused, selection is purely geometric)\n\nReturns\n\nnextidx::Int: Index of the point with maximum distance to selected points\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.MaximumValue","page":"API Reference","title":"AdaptiveCrossApproximation.MaximumValue","text":"MaximumValue <: ValuePivStrat\n\nPivoting strategy that selects the index with maximum absolute value.\n\nThis is the standard pivoting strategy used in classical ACA algorithms also referred to as partial pivoting. At each iteration, it chooses the row or column with the largest absolute value among the unused indices, ensuring numerical stability and good approximation quality.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.MaximumValue-Tuple{AbstractArray{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.MaximumValue","text":"(::MaximumValue)(idcs::AbstractArray{Int})\n\nCreate a MaximumValueFunctor for the given index array.\n\nReturns a functor with tracking vector sized to match the length of idcs.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.MaximumValueFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.MaximumValueFunctor","text":"MaximumValueFunctor <: ValuePivStratFunctor\n\nStateful functor that tracks which indices have been used during pivot selection.\n\nCreated by calling a MaximumValue instance with length or index information. Maintains a boolean vector to ensure each index is selected at most once.\n\nFields\n\nusedidcs::Vector{Bool}: Tracks which indices have been selected as pivots\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.MaximumValueFunctor-Tuple{AbstractArray}","page":"API Reference","title":"AdaptiveCrossApproximation.MaximumValueFunctor","text":"(pivstrat::MaximumValueFunctor)(rc::AbstractArray)\n\nSelect the unused index with maximum absolute value in rc.\n\nSearches through all unused indices, finds the one with largest abs(rc[i]), marks it as used, and returns its index.\n\nArguments\n\nrc::AbstractArray: Row or column data to select from\n\nReturns\n\nnextidx::Int: Index of the maximum absolute value among unused indices\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.MaximumValueFunctor-Tuple{}","page":"API Reference","title":"AdaptiveCrossApproximation.MaximumValueFunctor","text":"(pivstrat::MaximumValueFunctor)()\n\nSelect the first index as the initial pivot.\n\nReturns 1 and marks it as used. Used when no row/column data is available yet.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.MimicryPivoting","page":"API Reference","title":"AdaptiveCrossApproximation.MimicryPivoting","text":"MimicryPivoting{D,F<:Real} <: GeoPivStrat\n\nGeometric pivoting strategy that mimics point distribution of a fully pivoted ACA geometrically.\n\nSelects pivots to reproduce the spatial distribution of a fully pivoted ACA. The strategy balances three objectives: geometric separation (Leja-like behavior), proximity to the reference distribution, and fill distance maximization. Particularly useful for H²–matrix compression where incomplete factorizations are sufficient.\n\nFields\n\nrefpos::Vector{SVector{D,F}}: Positions of test or expansion domain\npos::Vector{SVector{D,F}}: Positions from which to select pivots\n\nType Parameters\n\nD: Spatial dimension\nF: Floating point type for coordinates\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.MimicryPivoting-Union{Tuple{F}, Tuple{D}, Tuple{Any, Any}} where {D, F}","page":"API Reference","title":"AdaptiveCrossApproximation.MimicryPivoting","text":"(strat::MimicryPivoting{D,F})(refidcs, rcidcs)\n\nCreate a MimicryPivotingFunctor for the given reference and candidate indices.\n\nInitializes the functor by computing the centroid of the reference points and setting up weights that favor points close to this centroid. This encourages the selected pivots to spatially mimic the reference distribution.\n\nArguments\n\nrefidcs: Indices of reference points (e.g., parent cluster pivots)\nrcidcs: Indices of candidate points to select from (e.g., child cluster points)\n\nReturns\n\nMimicryPivotingFunctor: Initialized functor with computed weights and metrics\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.MimicryPivotingFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.MimicryPivotingFunctor","text":"MimicryPivotingFunctor{D,F<:Real} <: GeoPivStratFunctor\n\nFunctor for mimicry-based pivot selection.\n\nMaintains vectors for leja2 (h), leja (leja), and weights (w) based on distance to reference centroid.\n\nFields\n\npos::Vector{SVector{D,F}}: All geometric positions\nidcs::Vector{Int}: Current indices being considered for selection\nh::Vector{F}: Minimum distances from each point to selected points (fill distance)\nleja::Vector{F}: Product of distances to all selected points (Leja metric)\nw::Vector{F}: Weights based on inverse distance to reference centroid\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.MimicryPivotingFunctor-Union{Tuple{Int64}, Tuple{F}, Tuple{D}} where {D, F<:Real}","page":"API Reference","title":"AdaptiveCrossApproximation.MimicryPivotingFunctor","text":"(strat::MimicryPivotingFunctor{D,F})(npivot::Int)\n\nSelect next pivot balancing Leja separation, fill distance, and reference proximity.\n\nUses a composite metric that combines:\n\nLeja product (geometric separation from all selected points)\nFill distance (maximum minimum distance criterion)\nReference weights (proximity to target distribution)\n\nThe balance between these factors evolves with iteration number npivot.\n\nArguments\n\nnpivot::Int: Current pivot iteration number (influences weight balance)\n\nReturns\n\nGlobal index of the selected pivot point\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.MimicryPivotingFunctor-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F<:Real}","page":"API Reference","title":"AdaptiveCrossApproximation.MimicryPivotingFunctor","text":"(strat::MimicryPivotingFunctor{D,F})()\n\nSelect the first pivot based on proximity to reference centroid.\n\nChooses the point with maximum weight (closest to the reference centroid), then initializes distance metrics for subsequent pivot selection.\n\nReturns\n\nGlobal index of the selected pivot point\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.PivStrat","page":"API Reference","title":"AdaptiveCrossApproximation.PivStrat","text":"PivStrat\n\nAbstract base type for pivoting strategies in cross approximation algorithms.\n\nPivoting strategies determine which row or column to select at each iteration of the ACA algorithm. Concrete subtypes are typically stateless and callable, creating stateful PivStratFunctor instances when invoked with index information.\n\nSubtypes by Category\n\nGeoPivStrat: Geometric strategies (e.g., fill distance, Leja points)\nValuePivStrat: Value-based strategies (e.g., maximum absolute value)\nConvPivStrat: Convergence-driven strategies (e.g., random sampling)\n\nInterface\n\nConcrete subtypes should implement:\n\n(strategy::MyPivStrat)(len::Int): Create functor for len indices\n(strategy::MyPivStrat)(idcs::AbstractArray{Int}): Create functor for index array\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.PivStratFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.PivStratFunctor","text":"PivStratFunctor\n\nAbstract base type for stateful pivoting functors.\n\nFunctors maintain state during the pivot selection process (e.g., tracking which indices have been used). Created by calling a PivStrat instance with index information.\n\nInterface\n\nConcrete subtypes should implement:\n\n(functor::MyPivStratFunctor)(): Select initial pivot (no data available)\n(functor::MyPivStratFunctor)(rc::AbstractArray): Select next pivot based on row/column data\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSampling","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSampling","text":"RandomSampling{F<:Real} <: ConvCrit\n\nConvergence criterion based on random matrix entry sampling. Monitors approximation error at randomly sampled positions.\n\nFields\n\nnsamples::Int: Number of random samples to take\nfactor::F: Factor for automatic sample count (nsamples = factor * (nrows + ncols))\ntol::F: Convergence tolerance\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSampling-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{Int64}, AbstractArray{Int64}}} where T","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSampling","text":"(cc::RandomSampling)(K::AbstractMatrix{T}, rowidcs, colidcs)\n\nInitialize random sampling functor with sampled matrix entries.\n\nArguments\n\nK::AbstractMatrix{T}: Matrix to compress\nrowidcs::AbstractArray{Int}: Active row indices\ncolidcs::AbstractArray{Int}: Active column indices\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSampling-Union{Tuple{}, Tuple{F}} where F<:Real","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSampling","text":"RandomSampling(; factor=1.0, nsamples=0, tol=1e-4)\n\nConstruct random sampling convergence criterion.\n\nArguments\n\nfactor::F: Multiplier for automatic sample count (default: 1.0)\nnsamples::Int: Fixed sample count (default: 0, use factor instead)\ntol::F: Convergence tolerance (default: 1e-4)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSamplingFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSamplingFunctor","text":"RandomSamplingFunctor{F<:Real,K} <: ConvCritFunctor\n\nStateful random sampling convergence checker. Tracks residual error at sampled matrix entries across iterations.\n\nFields\n\nnormUV²::F: Squared Frobenius norm of approximation\nindices::Matrix{Int}: Sampled matrix positions (nsamples × 2)\nrest::Vector{K}: Residual values at sampled positions\ntol::F: Convergence tolerance\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSamplingFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSamplingFunctor","text":"(convcrit::RandomSamplingFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)\n\nCheck convergence using random sampling. Updates residuals at sampled positions and compares to tolerance.\n\nArguments\n\nrowbuffer::AbstractMatrix{K}: Row factor buffer\ncolbuffer::AbstractMatrix{K}: Column factor buffer\nnpivot::Int: Current pivot index\nmaxrows::Int: Number of active rows\nmaxcolumns::Int: Number of active columns\n\nReturns\n\nnpivot::Int: Final pivot count\ncontinue::Bool: Whether to continue iteration\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSamplingPivoting","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSamplingPivoting","text":"RandomSamplingPivoting <: ConvPivStrat\n\nPivoting strategy that uses the error of random sampling from the convergence estimation.\n\nInstead of selecting pivots based on maximum values or geometric properties, this strategy chooses pivots from randomly sampled indices used by a random sampling convergence criterion. Works in conjunction with RandomSamplingFunctor to provide statistically based pivot selection.\n\nFields\n\nrc::Int: Index indicating which coordinate (row=1 or column=2) to select from\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSamplingPivoting-Union{Tuple{AdaptiveCrossApproximation.RandomSamplingFunctor{F, K}}, Tuple{K}, Tuple{F}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSamplingPivoting","text":"(pivstrat::RandomSamplingPivoting)(convcrit::RandomSamplingFunctor{F,K})\n\nCreate a RandomSamplingPivotingFunctor linked to the convergence criterion.\n\nInitializes the functor by connecting it to the random sampling convergence criterion that tracks sampled indices and residuals.\n\nArguments\n\nconvcrit::RandomSamplingFunctor{F,K}: Random sampling convergence functor\n\nReturns\n\nRandomSamplingPivotingFunctor: Initialized functor linked to the criterion\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSamplingPivotingFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSamplingPivotingFunctor","text":"RandomSamplingPivotingFunctor{F,K} <: ConvPivStratFunctor\n\nStateful functor for random sampling-based pivot selection.\n\nLinks to a random sampling convergence criterion functor to access the randomly sampled indices and their residuals, selecting pivots from the worst-performing samples.\n\nFields\n\nconvcrit::RandomSamplingFunctor{F,K}: Convergence criterion with sample information\nrc::Int: Coordinate index (1 for row, 2 for column)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.RandomSamplingPivotingFunctor-Union{Tuple{AbstractArray}, Tuple{K}, Tuple{F}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.RandomSamplingPivotingFunctor","text":"(pivstrat::RandomSamplingPivotingFunctor{F,K})(::AbstractArray)\n\nSelect pivot from the sample with largest residual.\n\nExamines the random samples tracked by the convergence criterion and returns the row or column index (depending on rc) corresponding to the sample with the maximum residual error.\n\nArguments\n\n::AbstractArray: Row/column data (unused, selection based on random samples)\n\nReturns\n\nIndex from the worst-performing random sample\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.TreeMimicryPivoting","page":"API Reference","title":"AdaptiveCrossApproximation.TreeMimicryPivoting","text":"TreeMimicryPivoting{D,T,TreeType} <: GeoPivStrat\n\nTree-aware mimicry pivoting strategy.\n\nThis strategy adapts the MimicryPivoting idea to a hierarchical tree of clusters. Instead of selecting individual points directly, it navigates the tree to pick clusters and then nodes within those clusters so that the selected pivots mimic a reference distribution at multiple scales.\n\nFields\n\nrefpos::Vector{SVector{D,T}}: Reference positions to mimic (e.g., parent pivots)\npos::Vector{SVector{D,T}}: Candidate point positions\ntree::TreeType: Tree structure providing cluster centers, children and values\n\nType parameters\n\nD: spatial dimension\nT: numeric type for coordinates\nTreeType: type of the tree adapter (must implement center, values, children, firstchild)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.TreeMimicryPivoting-Union{Tuple{T}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, T}, 1}, Array{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T<:Real}","page":"API Reference","title":"AdaptiveCrossApproximation.TreeMimicryPivoting","text":"TreeMimicryPivoting(refpos, pos, tree)\n\nConvenience constructor inferring tree type. refpos and pos must be vectors of SVector{D,T} coordinates and tree must provide required methods.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.TreeMimicryPivoting-Union{Tuple{V}, Tuple{T}, Tuple{D}, Tuple{V, V, Int64}} where {D, T, V<:Vector{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.TreeMimicryPivoting","text":"(pivstrat::TreeMimicryPivoting)(F, refidcs, maxrank)\n\nInitialize a tree-aware mimicry functor.\n\nF is a vector of tree node candidates (e.g., root children). The function computes the reference centroid from refidcs and allocates usedidcs of length maxrank for storing selected point indices.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.TreeMimicryPivotingFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.TreeMimicryPivotingFunctor","text":"TreeMimicryPivotingFunctor{D,T,TreeType} <: GeoPivStratFunctor\n\nFunctor storing state for tree-based mimicry pivoting.\n\nFields\n\nF::Vector{Int}: Candidate cluster node indices to search\nc::SVector{D,T}: Reference centroid used to bias selection\ntree::TreeType: Tree providing cluster geometry and membership\npos::Vector{SVector{D,T}}: Point coordinates\nusedidcs::Vector{Int}: Selected global point indices (filled progressively)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.TreeMimicryPivotingFunctor-Union{Tuple{Int64}, Tuple{F}, Tuple{D}} where {D, F<:Real}","page":"API Reference","title":"AdaptiveCrossApproximation.TreeMimicryPivotingFunctor","text":"(pivstrat::TreeMimicryPivotingFunctor)(npivot)\n\nSelect subsequent pivots by finding a cluster and then selecting the best point within that cluster based on mimicry pivoting strategy.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.TreeMimicryPivotingFunctor-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F<:Real}","page":"API Reference","title":"AdaptiveCrossApproximation.TreeMimicryPivotingFunctor","text":"(pivstrat::TreeMimicryPivotingFunctor)()\n\nSelect the first pivot by locating a promising leaf cluster and choosing the point within that cluster that is closest to the reference centroid.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.ValuePivStrat","page":"API Reference","title":"AdaptiveCrossApproximation.ValuePivStrat","text":"ValuePivStrat <: PivStrat\n\nAbstract type for value-based pivoting strategies.\n\nThese strategies select pivots based on matrix element values sampled during the ACA algorithm. Most common approach for general matrices.\n\nConcrete Types\n\nMaximumValue: Selects index with maximum absolute value (standard ACA)\nRandomSampling: Random selection (for statistical approaches)\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.ValuePivStratFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.ValuePivStratFunctor","text":"ValuePivStratFunctor <: PivStratFunctor\n\nAbstract type for stateful value-based pivoting functors.\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.iACA","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"iACA{RowPivType,ColPivType,ConvCritType}\n\nIncomplete Adaptive Cross Approximation (iACA) compressor.\n\nUnlike standard ACA, iACA computes only half of the factorization. It uses geometric pivoting strategies (e.g., mimicry or tree mimicry) to select row or column pivots based solely on spatial information, making it super efficient for hierarchical matrix construction where only row or column samples are requiered.\n\nFields\n\nrowpivoting::RowPivType: Strategy for selecting row pivots (geometric)\ncolumnpivoting::ColPivType: Strategy for selecting column pivots\nconvergence::ConvCritType: Convergence criterion\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64}} where {RowPivType<:AdaptiveCrossApproximation.ValuePivStrat, ColPivType<:TreeMimicryPivoting, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{ValuePivStrat,TreeMimicryPivoting,ConvCrit})(rows, Ft, maxrank)\n\nInitialize iACA functor for tree-based column pivoting. For hierarchical matrices where column selection uses tree-aware mimicry.\n\nArguments\n\nrows::AbstractVector{Int}: Row indices\nFt::AbstractVector{Int}: Tree structure for column pivoting\nmaxrank::Int: Maximum rank for approximation\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64}} where {RowPivType<:TreeMimicryPivoting, ColPivType<:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{TreeMimicryPivoting,ValuePivStrat,ConvCrit})(Ft, cols, maxrank)\n\nInitialize iACA functor for tree-based row pivoting. For hierarchical matrices where row selection uses tree-aware mimicry.\n\nArguments\n\nFt::AbstractVector{Int}: Tree structure for row pivoting\ncols::AbstractVector{Int}: Column indices\nmaxrank::Int: Maximum rank for approximation\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}} where {RowPivType<:AdaptiveCrossApproximation.GeoPivStrat, ColPivType<:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{GeoPivStrat,ValuePivStrat,ConvCrit})(rows, cols)\n\nInitialize iACA functor for row matrix compression with geometric row pivoting. Creates functors for geometric row pivoting and value-based column pivoting.\n\nArguments\n\nrows::AbstractVector{Int}: Row indices for geometric pivoting\ncols::AbstractVector{Int}: Column indices for geometric pivoting\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}} where {RowPivType<:AdaptiveCrossApproximation.ValuePivStrat, ColPivType<:AdaptiveCrossApproximation.GeoPivStrat, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{ValuePivStrat,GeoPivStrat,ConvCrit})(rows, cols)\n\nInitialize iACA functor for column matrix compression with geometric column pivoting. Creates functors for value-based row pivoting and geometric column pivoting.\n\nArguments\n\nrows::AbstractVector{Int}: Row indices\ncols::AbstractVector{Int}: Column indices for geometric pivoting\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64}} where {K, RowPivType<:AdaptiveCrossApproximation.ValuePivStrat, ColPivType<:MimicryPivoting, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{ValuePivStrat,MimicryPivoting,ConvCrit})(A, rowbuffer, colbuffer, maxrank; kwargs...)\n\nConvenience method delegating to main computational routine for mimicry-based column pivoting.\n\nArguments\n\nA: Matrix to compress\nrowbuffer::AbstractArray{K}: Buffer for row data\ncolbuffer::AbstractArray{K}: Buffer for column data\nmaxrank::Int: Maximum rank\nrows: Row indices (optional keyword)\ncols: Column indices (optional keyword)\nrowidcs: Row index range (optional keyword)\ncolidcs: Column index range (optional keyword)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64}} where {K, RowPivType<:AdaptiveCrossApproximation.ValuePivStrat, ColPivType<:TreeMimicryPivoting, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{ValuePivStrat,TreeMimicryPivoting,ConvCrit})(A, rowbuffer, colbuffer, maxrank; kwargs...)\n\nConvenience method delegating to main computational routine for tree-based column pivoting.\n\nArguments\n\nA: Matrix to compress\nrowbuffer::AbstractArray{K}: Buffer for row data\ncolbuffer::AbstractArray{K}: Buffer for column data\nmaxrank::Int: Maximum rank\nrows: Row indices (optional keyword)\ncols: Column indices (optional keyword)\nrowidcs: Row index range (optional keyword)\ncolidcs: Column index range (optional keyword)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RowPivType<:MimicryPivoting, ColPivType<:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{MimicryPivoting,ValuePivStrat,ConvCrit})(A, colbuffer, rowbuffer, maxrank; kwargs...)\n\nConvenience method delegating to main computational routine for mimicry-based row pivoting.\n\nArguments\n\nA: Matrix to compress\ncolbuffer::AbstractMatrix{K}: Buffer for column data\nrowbuffer::AbstractMatrix{K}: Buffer for row data\nmaxrank::Int: Maximum rank\nrows: Row indices (optional keyword)\ncols: Column indices (optional keyword)\nrowidcs: Row index range (optional keyword)\ncolidcs: Column index range (optional keyword)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RowPivType<:TreeMimicryPivoting, ColPivType<:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType<:AdaptiveCrossApproximation.ConvCrit}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{TreeMimicryPivoting,ValuePivStrat,ConvCrit})(A, colbuffer, rowbuffer, maxrank; kwargs...)\n\nConvenience method delegating to main computational routine for tree-based row pivoting.\n\nArguments\n\nA: Matrix to compress\ncolbuffer::AbstractMatrix{K}: Buffer for column data\nrowbuffer::AbstractMatrix{K}: Buffer for row data\nmaxrank::Int: Maximum rank\nrows: Row indices (optional keyword)\ncols: Column indices (optional keyword)\nrowidcs: Row index range (optional keyword)\ncolidcs: Column index range (optional keyword)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{F}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, F}, 1}, Array{StaticArraysCore.SVector{D, F}, 1}}} where {D, F<:Real}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"iACA(tpos::Vector{SVector{D,F}}, spos::Vector{SVector{D,F}})\n\nConstruct an iACA compressor with default settings for geometric pivoting.\n\nCreates an iACA using maximum value for row pivoting, mimicry pivoting for columns (mimicking the spatial distribution of a fully pivoting when selecting from spos), and Frobenius norm extrapolation for convergence.\n\nArguments\n\ntpos: Test/target point positions (reference distribution)\nspos: Source point positions (candidates for selection)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{T}, Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64, T, T, T}} where {K, RowPivType<:AdaptiveCrossApproximation.ValuePivStratFunctor, ColPivType<:AdaptiveCrossApproximation.GeoPivStratFunctor, ConvCritType<:AdaptiveCrossApproximation.ConvCritFunctor, T<:Vector{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{ValuePivStratFunctor,GeoPivStratFunctor,ConvCritFunctor})(A, colbuffer, rowbuffer, maxrank, rows, cols, rowidcs)\n\nMain computational routine for column matrix iACA (value-based row pivoting, geometric column pivoting). Performs incomplete ACA compression where columns are selected geometrically and rows by maximum value.\n\nArguments\n\nA: Matrix to compress\ncolbuffer::AbstractArray{K}: Buffer for column data\nrowbuffer::AbstractArray{K}: Buffer for row data\nmaxrank::Int: Maximum rank\nrows::Vector{Int}: Row indices storage\ncols::Vector{Int}: Column indices storage\nrowidcs::Vector{Int}: Row index range\n\nReturns\n\nnpivot::Int: Number of pivots computed\nrows::Vector{Int}: Selected row indices (global)\ncols::Vector{Int}: Selected column indices\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iACA-Union{Tuple{T}, Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64, T, T, T}} where {K, RowPivType<:AdaptiveCrossApproximation.GeoPivStratFunctor, ColPivType<:AdaptiveCrossApproximation.ValuePivStratFunctor, ConvCritType<:AdaptiveCrossApproximation.ConvCritFunctor, T<:Vector{Int64}}","page":"API Reference","title":"AdaptiveCrossApproximation.iACA","text":"(iaca::iACA{GeoPivStratFunctor,ValuePivStratFunctor,ConvCritFunctor})(A, colbuffer, rowbuffer, maxrank, rows, cols, colidcs)\n\nMain computational routine for row matrix iACA (geometric row pivoting, value-based column pivoting). Performs incomplete ACA compression where rows are selected geometrically and columns by maximum value.\n\nArguments\n\nA: Matrix to compress\ncolbuffer::AbstractMatrix{K}: Buffer for column data\nrowbuffer::AbstractMatrix{K}: Buffer for row data\nmaxrank::Int: Maximum rank\nrows::Vector{Int}: Row indices storage\ncols::Vector{Int}: Column indices storage\ncolidcs::Vector{Int}: Column index range\n\nReturns\n\nnpivot::Int: Number of pivots computed\nrows::Vector{Int}: Selected row indices\ncols::Vector{Int}: Selected column indices (global)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iFNormEstimator","page":"API Reference","title":"AdaptiveCrossApproximation.iFNormEstimator","text":"iFNormEstimator{F} <: ConvCrit\n\nFrobenius norm-based convergence criterion for incomplete ACA (iACA). Uses moving average norm estimate for geometric pivoting scenarios.\n\nFields\n\ntol::F: Relative tolerance threshold\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.iFNormEstimator-Union{Tuple{}, Tuple{F}} where F","page":"API Reference","title":"AdaptiveCrossApproximation.iFNormEstimator","text":"(cc::iFNormEstimator{F})()\n\nInitialize iFNormEstimator functor with zero accumulated norm.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.iFNormEstimatorFunctor","page":"API Reference","title":"AdaptiveCrossApproximation.iFNormEstimatorFunctor","text":"iFNormEstimatorFunctor{F} <: ConvCritFunctor\n\nStateful Frobenius norm estimator for iACA compression. Tracks moving average of row/column norms.\n\nFields\n\nnormUV::F: Moving average norm\ntol::F: Relative tolerance threshold\n\n\n\n\n\n","category":"type"},{"location":"apiref/#AdaptiveCrossApproximation.iFNormEstimatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractVector{K}, Int64}} where {F<:Real, K}","page":"API Reference","title":"AdaptiveCrossApproximation.iFNormEstimatorFunctor","text":"(convcrit::iFNormEstimatorFunctor)(rcbuffer::AbstractVector{K}, npivot::Int)\n\nCheck convergence for iACA using moving average norm. Returns (npivot, continue) where continue is true if iteration should proceed.\n\nArguments\n\nrcbuffer::AbstractVector{K}: Current row or column buffer\nnpivot::Int: Current pivot index\n\nReturns\n\nnpivot::Int: Final pivot count\ncontinue::Bool: Whether to continue iteration\n\n\n\n\n\n","category":"method"},{"location":"apiref/#Core.Union-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F}","page":"API Reference","title":"Core.Union","text":"(pivstrat::Union{Leja2Functor{D,F},FillDistanceFunctor{D,F}})()\n\nSelect the first point as the initial pivot.\n\nComputes distances from all points to the first point and returns index 1.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.aca-Union{Tuple{AbstractMatrix{K}}, Tuple{K}} where K","page":"API Reference","title":"AdaptiveCrossApproximation.aca","text":"aca(M; tol=1e-4, rowpivoting=MaximumValue(), columnpivoting=MaximumValue(),\n    convergence=FNormEstimator(tol), maxrank=40, svdrecompress=false)\n\nCompute adaptive cross approximation of matrix M returning low-rank factors.\n\nHigh-level convenience function that automatically allocates buffers and returns U, V such that M ≈ U * V.\n\nArguments\n\nM::AbstractMatrix{K}: Matrix to approximate\n\nKeyword Arguments\n\ntol::Real = 1e-4: Approximation tolerance\nrowpivoting = MaximumValue(): Row pivot selection strategy\ncolumnpivoting = MaximumValue(): Column pivot selection strategy\nconvergence = FNormEstimator(tol): Convergence criterion\nmaxrank::Int = 40: Maximum rank (hard limit)\nsvdrecompress::Bool = false: Apply SVD-based recompression to reduce rank further\n\nReturns\n\nU::Matrix{K}: Left factor, size (size(M,1), r) where r ≤ maxrank\nV::Matrix{K}: Right factor, size (r, size(M,2))\n\nSatisfies M ≈ U * V with norm(M - U*V) / norm(M) ≲ tol (if maxrank sufficient).\n\nSVD Recompression\n\nWhen svdrecompress=true, performs QR-SVD recompression: computes M ≈ U*V, then U = Q*R, R*V = Û*Σ*V̂ᵀ, truncates small singular values, and returns optimal rank factors at the cost of additional computation.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.acaᵀ-Union{Tuple{AbstractMatrix{K}}, Tuple{K}} where K","page":"API Reference","title":"AdaptiveCrossApproximation.acaᵀ","text":"acaᵀ(M; tol=1e-4, rowpivoting, columnpivoting, convergence, maxrank=40)\n\nConvenience function for column-first ACA compression. Automatically allocates buffers and performs compression.\n\nArguments\n\nM::AbstractMatrix{K}: Matrix to compress\ntol: Convergence tolerance (default: 1e-4)\nrowpivoting: Row pivoting strategy (default: MaximumValueFunctor)\ncolumnpivoting: Column pivoting strategy (default: MaximumValueFunctor)\nconvergence: Convergence criterion (default: FNormEstimator(0.0, tol))\nmaxrank: Maximum rank (default: 40)\n\nReturns\n\ncolbuffer: Column factor (nrows × npivots)\nrowbuffer: Row factor (npivots × ncols)\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.findcluster-Union{Tuple{I}, Tuple{T}, Tuple{D}, Tuple{AdaptiveCrossApproximation.TreeMimicryPivotingFunctor{D, T}, Vector{I}, I}} where {D, T<:Real, I}","page":"API Reference","title":"AdaptiveCrossApproximation.findcluster","text":"findcluster(pivstrat, F, npivot)\n\nCluster-based selection used during later pivot iterations.\n\nFor each candidate cluster f in F, compute a composite score combining Leja products, fill distances and inverse-distance weights to the reference centroid; select the cluster maximizing this score and recurse until a leaf is reached.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.findcluster-Union{Tuple{I}, Tuple{T}, Tuple{D}, Tuple{AdaptiveCrossApproximation.TreeMimicryPivotingFunctor{D, T}, Vector{I}}} where {D, T<:Real, I}","page":"API Reference","title":"AdaptiveCrossApproximation.findcluster","text":"findcluster(pivstrat, F)\n\nFind a leaf cluster (node) that best matches the reference centroid.\n\nTraverses the tree greedily by choosing child clusters whose centers are closest (in weighted inverse-distance sense) to the reference centroid pivstrat.c. Returns a node index whose firstchild is zero (leaf) or recurses into children.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.leja2!-Tuple{AdaptiveCrossApproximation.GeoPivStratFunctor, Int64}","page":"API Reference","title":"AdaptiveCrossApproximation.leja2!","text":"leja2!(pivstrat::GeoPivStratFunctor, nextidx::Int)\n\nUpdate minimum distances after selecting pivot nextidx.\n\nComputes distances from all points to the newly selected pivot and updates the minimum distance vector h by taking element-wise minimum with new distances. This shared helper is used by both Leja2 and fill distance strategies.\n\nArguments\n\npivstrat::GeoPivStratFunctor: Functor with distance vector to update\nnextidx::Int: Index of newly selected pivot\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.nextrc!-Tuple{Any, AbstractArray, Any, Any}","page":"API Reference","title":"AdaptiveCrossApproximation.nextrc!","text":"nextrc!(buf, A::AbstractArray, i, j)\n\nFill buffer buf with submatrix A[i, j].\n\nInternal utility for matrix element access. Can be extended for custom matrix types to enable ACA compression of matrix-free operators.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.normF!-Union{Tuple{K}, Tuple{AdaptiveCrossApproximation.ConvCritFunctor, AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where K","page":"API Reference","title":"AdaptiveCrossApproximation.normF!","text":"normF!(convcrit::ConvCritFunctor, rowbuffer, colbuffer, npivot, maxrows, maxcolumns)\n\nUpdate Frobenius norm estimate for standard ACA. Incrementally computes squared norm of UV factorization using current pivot and all previous pivots.\n\nArguments\n\nconvcrit::ConvCritFunctor: Convergence criterion functor to update\nrowbuffer::AbstractMatrix{K}: Row factor buffer\ncolbuffer::AbstractMatrix{K}: Column factor buffer\nnpivot::Int: Current pivot index\nmaxrows::Int: Number of active rows\nmaxcolumns::Int: Number of active columns\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.normF!-Union{Tuple{K}, Tuple{AdaptiveCrossApproximation.ConvCritFunctor, AbstractVector{K}, Int64}} where K","page":"API Reference","title":"AdaptiveCrossApproximation.normF!","text":"normF!(convcrit::ConvCritFunctor, rcbuffer::AbstractVector{K}, npivot::Int)\n\nUpdate running norm estimate for incomplete ACA (iACA). Computes moving average of row/column norms across pivots.\n\nArguments\n\nconvcrit::ConvCritFunctor: Convergence criterion functor to update\nrcbuffer::AbstractVector{K}: Current row or column buffer\nnpivot::Int: Current pivot index\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.FNormExtrapolatorFunctor}","page":"API Reference","title":"AdaptiveCrossApproximation.tolerance","text":"tolerance(cc::FNormExtrapolatorFunctor)\n\nGet tolerance from underlying estimator.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.RandomSamplingFunctor}","page":"API Reference","title":"AdaptiveCrossApproximation.tolerance","text":"tolerance(cc::RandomSamplingFunctor)\n\nGet tolerance from random sampling functor.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.iFNormEstimatorFunctor}","page":"API Reference","title":"AdaptiveCrossApproximation.tolerance","text":"tolerance(cc::iFNormEstimatorFunctor)\n\nGet tolerance threshold from iACA estimator functor.\n\n\n\n\n\n","category":"method"},{"location":"apiref/#AdaptiveCrossApproximation.tolerance-Tuple{FNormEstimator}","page":"API Reference","title":"AdaptiveCrossApproximation.tolerance","text":"tolerance(cc::FNormEstimator)\n\nGet tolerance threshold from estimator.\n\n\n\n\n\n","category":"method"},{"location":"details/iaca/#Incomplete-Adaptive-Cross-Approximation","page":"iACA","title":"Incomplete Adaptive Cross Approximation","text":"","category":"section"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In order to contribute to this package directly create a pull request against the main branch. Before doing so please: ","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Follow the style of the surrounding code.\nSupplement the documentation.\nWrite tests and check that no errors occur.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Style","page":"Contributing","title":"Style","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a consistent style the JuliaFormatter.jl package is used which enforces the style defined in the .JuliaFormatter.toml file. To follow this style simply run","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using JuliaFormatter\nformat(pkgdir(AdaptiveCrossApproximation))","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"note: Note\nThat all files follow the JuliaFormatter style is tested during the unit tests. Hence, do not forget to execute the two lines above. Otherwise, the tests are likely to not pass.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#Documentation","page":"Contributing","title":"Documentation","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Add documentation for any changes or new features following the style of the existing documentation. For more information you can have a look at the Documenter.jl documentation.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"","category":"page"},{"location":"contributing/#tests","page":"Contributing","title":"Tests","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Write tests for your code changes and verify that no errors occur, e.g., by running","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"AdaptiveCrossApproximation.jl\")","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"For a detailed information on which parts are tested the coverage can be evaluated on your local machine, e.g., by","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"using Pkg\nPkg.test(\"AdaptiveCrossApproximation\"; coverage=true, julia_args=[\"-t 4\"])\n\n# determine coverage\nusing Coverage\nsrc_folder = pkgdir(AdaptiveCrossApproximation) * \"/src\"\ncoverage   = process_folder(src_folder)\nLCOV.writefile(\"path-to-folder-you-like\" * \"AdaptiveCrossApproximation.lcov.info\", coverage)\n\nclean_folder(src_folder) # delete .cov files\n\n# extract information about coverage\ncovered_lines, total_lines = get_summary(coverage)\n@info \"Current coverage:\\n$covered_lines of $total_lines lines ($(round(Int, covered_lines / total_lines * 100)) %)\"","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"In Visual Studio Code the Coverage Gutters plugin can be used to visualize the tested lines of the code by inserting the path of the AdaptiveCrossApproximation.lcov.info file in the settings.","category":"page"},{"location":"details/aca/#Adaptive-Cross-Approximation","page":"ACA","title":"Adaptive Cross Approximation","text":"","category":"section"},{"location":"details/aca/#Introduction","page":"ACA","title":"Introduction","text":"","category":"section"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"The Adaptive Cross Approximation (ACA) algorithm computes a low-rank approximation of a matrix $ \\bm A^{m \\times n}$ using only a small subset of rows and columns.  The algorithm builds a factorization of the form","category":"page"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"bm A approx bm U bm V^T = sum_k=1^r bm u_k bm v_k^T","category":"page"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"where bm U in mathbbR^m times r and bm V in mathbbR^n times r are computed iteratively by selecting rows and columns of bm A.","category":"page"},{"location":"details/aca/#Algorithm","page":"ACA","title":"Algorithm","text":"","category":"section"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"The ACA algorithm proceeds as follows:","category":"page"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"Select and sample first row: bm v_1^textT = bm Ai_1 \nSelect column: Choose column index j_1 \nSample column: Sample column bm u_1 = A j_1\nNormalize: bm v_1 = bm v_1  bm v_1 j_1\nIterate: Until convergence criterion is met, for r = 2 3 ldots:\nSelect row index i_r \nSample and update row: bm v_r^T = bm Ai_r  - sum_k=1^r-1 bm u_k i_r bm v_k^T\nSelect column index j_r \nSample and update column: bm u_r = bm Ai_r  -sum_k=1^r-1 bm u_k bm v_k j_r\nNormalize: bm v_r =bm v_r  bm v_r j_r","category":"page"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"API: ACA","category":"page"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"ACAᵀ: The column-first variant starts by selecting a column, then a row, reversing the standard order.  This can be advantageous when the matrix structure favors column operations.","category":"page"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"API: AdaptiveCrossApproximation.ACAᵀ ","category":"page"},{"location":"details/aca/#Pivoting","page":"ACA","title":"Pivoting","text":"","category":"section"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"To select the row and column indices i_r and j_r different pivoting strategies can be employed.  In this package several strategies are implemented, e.g., maximum value pivoting, random sampling pivoting, fill distance pivoting, Leja2 pivoting, mimicry pivoting, and tree mimicry pivoting.  For more details see the pivoting strategy documentation.","category":"page"},{"location":"details/aca/#Convergence-Criteria","page":"ACA","title":"Convergence Criteria","text":"","category":"section"},{"location":"details/aca/","page":"ACA","title":"ACA","text":"To determine when to stop the iteration different convergence criteria can be used. In this package several criteria are implemented, e.g., the Frobenius norm estimator, a random sample based criterion, and an extrapolation based criterion.  For more details see the convergence criteria documentation.","category":"page"},{"location":"#AdaptiveCrossApproximation","page":"Introduction","title":"AdaptiveCrossApproximation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides different flavors of the adaptive cross approximation [1, 2]. Beside the standard algorithm this package allows to use several different pivoting strategies and convergence criteria. Further more this package contains an incomplete adaptive cross approximation allowing an efficient pivoting selection for the construction of mathcalH^2-matrices.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Installing AdaptiveCrossApproximation is done by entering the package manager (enter ] at the julia REPL) and issuing:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pkg> add https://github.com/FastBEAST/AdaptiveCrossApproximation.jl.git","category":"page"},{"location":"#refs","page":"Introduction","title":"References","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"[1] Bebendorf, Mario. Adaptive Cross Approximation of Multidimensional Arrays. Computing 70, no. 1 (January 2003): 1–24. https://doi.org/10.1007/s00607-002-0019-1.\n[2] Zhao, K., M.N. Vouvakis, and J.-F. Lee. “The Adaptive Cross Approximation Algorithm for Accelerated Method of Moments Computations of EMC Problems.” IEEE Transactions on Electromagnetic Compatibility 47, no. 4 (2005): 763–73. https://doi.org/10.1109/TEMC.2005.857898.\n[3] Bauer, M., M. Bebendorf, and B. Feist. Kernel-Independent Adaptive Construction of mathcal H^2-Matrix Approximations. Numerische Mathematik 150, no. 1 (January 2022): 1–32. https://doi.org/10.1007/s00211-021-01255-y.\n[4] Heldring, Alexander, Eduard Ubeda, and Juan M. Rius. Improving the Accuracy of the Adaptive Cross Approximation with a Convergence Criterion Based on Random Sampling. IEEE Transactions on Antennas and Propagation 69, no. 1 (January 2021): 347–55. https://doi.org/10.1109/TAP.2020.3010857.\n[5] De Marchi, Stefano. On Leja Sequences: Some Results and Applications. Applied Mathematics and Computation 152, no. 3 (2004): 621–47. https://doi.org/10.1016/S0096-3003(03)00580-0.\n[6] Tetzner, Joshua M., and Simon B. Adrian. “On the Adaptive Cross Approximation for the Magnetic Field Integral Equation.” IEEE Transactions on Antennas and Propagation, 2024, 1–1. https://doi.org/10.1109/TAP.2024.3483296.\n[7] Tetzner, Joshua M., and Simon B. Adrian. “The Incomplete Adaptive Cross Approximation for the Fast Construction of H² -Matrices and Its Application to the Electric Field Integral Equation for Electrically Small Problems.” Preprint, Preprints, November 10, 2025. https://doi.org/10.36227/techrxiv.176281137.74736897/v1.","category":"page"},{"location":"details/convergence/#Convergence-Criteria","page":"Convergence Criteria","title":"Convergence Criteria","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"Convergence criteria determine when to stop the ACA iteration.","category":"page"},{"location":"details/convergence/#Frobenius-Norm-Estimation","page":"Convergence Criteria","title":"Frobenius Norm Estimation","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"The Frobenius norm estimator is the standard convergence criterion for ACA algorithms [1, 2]. It estimates the Frobenius norm of the residual matrix as well as the full matrix using only the entries evaluated during the ACA process.","category":"page"},{"location":"details/convergence/#ACA","page":"Convergence Criteria","title":"ACA","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"For ACA, the squared Frobenius norm of the full matrix is tracked incrementally by","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":" A^mtimes n  _textF^2 approx bm U bm V^T_textF^2 = sum_k=1^r bm u_k^2bm v_k^2 + 2sum_ij langle bm u_i bm u_j rangle langle bm v_i bm v_j rangle","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"At iteration r, the algorithm checks if","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"bm u_r bm v_r  varepsilon cdot bm U bm V^T_F","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"API: FNormEstimator","category":"page"},{"location":"details/convergence/#Incomplete-ACA-(iACA)","page":"Convergence Criteria","title":"Incomplete ACA (iACA)","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"For incomplete ACA less entries of the matrix are sampled, therefore, in the case of the the Frobenius norm of the full matrix is estimated following [7] by","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"A^mtimes n _F^2 approx sqrtfracnr A^mtimes r_textF","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"and at iteration r the algorithm checks if","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"a  varepsilon frac A^mtimes r_textFsqrtr ","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"This simpler criterion requires only current pivot norms, not historical inner products.","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"API: iFNormEstimator","category":"page"},{"location":"details/convergence/#Random-Sampling","page":"Convergence Criteria","title":"Random Sampling","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"Random sampling convergence criteria estimates the residual error by computing the true error for a set of randomly selected matrix entries, following [4, 6], and checks at iteration r if","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"sqrttextmean(bm e_r²)mn  varepsilon bm U bm V^T_textF","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"API: AdaptiveCrossApproximation.RandomSampling","category":"page"},{"location":"details/convergence/#Extrapolation-Based-Criteria","page":"Convergence Criteria","title":"Extrapolation-Based Criteria","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"Extrapolation criteria enhances the Frobenius norm estimation by predicting the residual norm decay based on previous iterations, following [7].  This criterion can be used to smooth out fluctuations in the estimated error and prevent premature convergence.  At iteration r, if the Frobenius norm estimation is satisfied, the algorithm fits the logarithm of the residual norms of the previous iterations to a quadratic polynomial and extrapolates to the rth iteration and checks if  P²(r)  log(varepsilon bm U bm V^T_F)","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"API: FNormExtrapolator","category":"page"},{"location":"details/convergence/#Combined-Criteria","page":"Convergence Criteria","title":"Combined Criteria","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"The combined convergence criterion allows to combine multiple convergence criteria which all have to be satisfied to terminate the ACA process. This criterion can be used to control the operating pivoting strategy. ","category":"page"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"API: AdaptiveCrossApproximation.CombinedConvCrit","category":"page"},{"location":"details/convergence/#Choosing-a-Criterion","page":"Convergence Criteria","title":"Choosing a Criterion","text":"","category":"section"},{"location":"details/convergence/","page":"Convergence Criteria","title":"Convergence Criteria","text":"The choice of convergence criterion should be guided by the specific characteristics of the problem and computational constraints. The standard Frobenius norm estimation is in the case of the ACA suitable for most applications. For the IACA the Extrapolation based criterion is recommended.","category":"page"},{"location":"details/pivoting/#Pivoting-Strategies","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Pivoting strategies determine how rows and columns are selected during ACA compression. The choice of pivoting strategy significantly affects both the accuracy and computational cost of the approximation.","category":"page"},{"location":"details/pivoting/#Value-Based-Strategies","page":"Pivoting Strategies","title":"Value-Based Strategies","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Value-based strategies select pivots by examining matrix entries to find the most significant components.","category":"page"},{"location":"details/pivoting/#Maximum-Value-Pivoting","page":"Pivoting Strategies","title":"Maximum Value Pivoting","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"The maximum value strategy, also referred to as partial pivoting [1, 2], selects the pivot with the largest absolute value in the current residual.  In the standard ACA when starting with the first row, all following columns are selected as","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"argmax_j bm v_r j","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"and all rows for r  1 are selected as","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"argmax_i bm u_r-1 i","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"API: MaximumValue","category":"page"},{"location":"details/pivoting/#Random-Sampling","page":"Pivoting Strategies","title":"Random Sampling","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Random sampling pivoting is typically combined with the random sampling convergence criterion or a combined convergence criterion. It selects the next row or column leveraging the randomly sampled entries of the underlying matrix used in the convergence criterion, choosing row or column of the sample with the maximum absolute error after the r-th iteration, following ","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"argmax_k bm e_r k \n\nwhere bm e_r contains the error of the sampled entries after the r-th iteration\n\nIn the random sampling convergence criterion the mean error of the random samples is used to estimate the overall residual error\n\n\nAPI RandomSamplingPivoting(ref)\n\n Geometry-Based Strategies\n\nGeometry-based strategies exploit spatial information about the underlying point sets or basis functions\n\n Fill Distance\nThe fill distance strategy following 3(ref refs) selects the row or column associated with geometrical positions bm x in X that minimize the fill distance\n\nbm hcoloneqq sup_bm x in Xtextdist(bm x X_r)","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"where textdist(bm x X_r) = min_bm y in X_r bm x - bm y and X_r is the set of already selected points associated with rows or columns after r iterations, from one step to the next. This strategy aims to cover the domain uniformly, ensuring that no region is left unrepresented.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Note: this strategy should be used only either for the rows or the columns, not both simultaneously and be combined with partial pivoting.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"API: FillDistance","category":"page"},{"location":"details/pivoting/#Modified-Leja-Points","page":"Pivoting Strategies","title":"Modified Leja Points","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Modified Leja points, following [5], follow a similar idea to the fill distance strategy but instead of minimizing the fill distance in each iteration selects the node furthest away from the already selected points X_r:","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"argmax_i (bm h_i)","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"This approach results in a similar geometrical distribution as the fill distance strategy, however, it is significantly more efficient.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Note: this strategy should be used only either for the rows or the columns, not both simultaneously and be combined with partial pivoting.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"API: Leja2","category":"page"},{"location":"details/pivoting/#Mimicry-Pivoting","page":"Pivoting Strategies","title":"Mimicry Pivoting","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Mimicry pivoting, following [7], selects rows or columns based on geometric information to mimic the geometric distribution of the positions associated with the rows or columns picked by the partial pivoting.  This is achieved by solving in each the maximization problem","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"argmax_jbm x_j in X biggr big(textdist(bm x_j X_r)big)biggr(prod_bm x_i in X_rbm x_i-bm x_jbiggr)^1rbig(bm x_j-bm cbig)^-4biggr","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"where bm c is the geometric center of the positions associated with the rows when columns are selected and the other way around.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"This strategy is designed for the incomplete ACA (iACA).","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Note: this strategy should be used only either for the rows or the columns, not both simultaneously and be combined with partial pivoting.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"API: MimicryPivoting","category":"page"},{"location":"details/pivoting/#Tree-Mimicry-Pivoting","page":"Pivoting Strategies","title":"Tree Mimicry Pivoting","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"Tree mimicry pivoting extends the mimicry pivoting strategy by leveraging a hierarchical clustering of the geometric positions associated with the rows and columns.  The hierarchical clustering of the positions hast to be passed to the pivoting strategy. For details see [7].","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"API: TreeMimicryPivoting","category":"page"},{"location":"details/pivoting/#Combined-Strategies","page":"Pivoting Strategies","title":"Combined Strategies","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"The combined pivoting strategy allows mixing different pivoting strategies combined with multiple convergence criteria, that decide which strategy to use at each step, enabling hybrid approaches.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"API: AdaptiveCrossApproximation.CombinedPivStrat","category":"page"},{"location":"details/pivoting/#Choosing-a-Strategy","page":"Pivoting Strategies","title":"Choosing a Strategy","text":"","category":"section"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"The choice of pivoting strategy should be guided by the specific characteristics of the problem at hand, including the nature of the matrix, desired accuracy, and computational resources. In general the solid results are obtained using the maximum value pivoting strategy.","category":"page"},{"location":"details/pivoting/","page":"Pivoting Strategies","title":"Pivoting Strategies","text":"For spatial problems where the zeros blocks arise in the matrix structure, geometry-based strategies or random sampling pivoting can provide better performance. For details see [6].","category":"page"}]
}
