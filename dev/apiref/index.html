<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · AdaptiveCrossApproximation.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="AdaptiveCrossApproximation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AdaptiveCrossApproximation.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/manual/">General Usage</a></li><li><a class="tocitem" href="../manual/examples/">Application Examples</a></li></ul></li><li><span class="tocitem">Further Details</span><ul><li><a class="tocitem" href="../details/aca/">ACA</a></li><li><a class="tocitem" href="../details/iaca/">iACA</a></li><li><a class="tocitem" href="../details/pivoting/">Pivoting Strategies</a></li><li><a class="tocitem" href="../details/convergence/">Convergence Criteria</a></li></ul></li><li><a class="tocitem" href="../contributing/">Contributing</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/main/docs/src/apiref.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACA" href="#AdaptiveCrossApproximation.ACA"><code>AdaptiveCrossApproximation.ACA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ACA{RowPivType,ColPivType,ConvCritType}</code></pre><p>Adaptive Cross Approximation (ACA) compressor for low-rank matrix approximation.</p><p>Computes <code>M ≈ U * V</code> by iteratively selecting rows and columns (pivots) until a convergence criterion is met. The algorithm starts with row, samples it to select a column pivot, then alternates between row and column selection.</p><p><strong>Fields</strong></p><ul><li><code>rowpivoting::RowPivType</code>: Strategy for selecting row pivots</li><li><code>columnpivoting::ColPivType</code>: Strategy for selecting column pivots</li><li><code>convergence::ConvCritType</code>: Convergence criterion to stop iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACA-Tuple{AbstractArray{Int64}, AbstractArray{Int64}}" href="#AdaptiveCrossApproximation.ACA-Tuple{AbstractArray{Int64}, AbstractArray{Int64}}"><code>AdaptiveCrossApproximation.ACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(aca::ACA)(rowidcs::AbstractArray{Int}, colidcs::AbstractArray{Int})</code></pre><p>Create a specialized ACA instance for a submatrix defined by index sets.</p><p>Initializes pivoting functors with the provided row and column indices. Used internally for hierarchical matrix compression.</p><p><strong>Arguments</strong></p><ul><li><code>rowidcs</code>: Row indices of the submatrix</li><li><code>colidcs</code>: Column indices of the submatrix</li></ul><p><strong>Returns</strong></p><p>New <code>ACA</code> instance with initialized pivoting state for the given indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L48-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACA-Tuple{}" href="#AdaptiveCrossApproximation.ACA-Tuple{}"><code>AdaptiveCrossApproximation.ACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ACA(; rowpivoting=MaximumValue(), columnpivoting=MaximumValue(),
      convergence=FNormEstimator(1e-4))</code></pre><p>Construct an ACA compressor with keyword arguments.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>rowpivoting</code>: Row pivot selection strategy (default: <code>MaximumValue()</code>)</li><li><code>columnpivoting</code>: Column pivot selection strategy (default: <code>MaximumValue()</code>)</li><li><code>convergence</code>: Convergence criterion (default: <code>FNormEstimator(1e-4)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L28-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACA-Union{Tuple{C}, Tuple{CP}, Tuple{RP}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RP&lt;:AdaptiveCrossApproximation.PivStrat, CP&lt;:AdaptiveCrossApproximation.PivStrat, C&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.ACA-Union{Tuple{C}, Tuple{CP}, Tuple{RP}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RP&lt;:AdaptiveCrossApproximation.PivStrat, CP&lt;:AdaptiveCrossApproximation.PivStrat, C&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.ACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(aca::ACA{P,P,C})(A, colbuffer, rowbuffer, maxrank; kwargs...)</code></pre><p>Convenience method that initializes pivoting functors when using uniform strategies.</p><p>Delegates to the main computational routine after creating index-specialized functors. Only available when both pivoting strategies are of the same stateless type <code>P &lt;: PivStrat</code>.</p><p>See the main <code>(aca::ACA)(A, colbuffer, rowbuffer, rows, cols, rowidcs, colidcs, maxrank)</code> method for detailed argument documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L103-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACA-Union{Tuple{T}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, T, T, T, T, Int64}} where {K, T&lt;:Vector{Int64}}" href="#AdaptiveCrossApproximation.ACA-Union{Tuple{T}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, T, T, T, T, Int64}} where {K, T&lt;:Vector{Int64}}"><code>AdaptiveCrossApproximation.ACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(aca::ACA)(A, colbuffer, rowbuffer, rows, cols, rowidcs, colidcs, maxrank)</code></pre><p>Compute ACA approximation with preallocated buffers (main computational routine).</p><p>Fills <code>colbuffer</code> and <code>rowbuffer</code> with low-rank factors U and V such that <code>A[rowidcs, colidcs] ≈ U * V</code>. Uses deflation to ensure orthogonality of pivots.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix or matrix-like object (must support <code>nextrc!</code> interface)</li><li><code>colbuffer::AbstractMatrix{K}</code>: Buffer for U factors, size <code>(length(rowidcs), maxrank)</code></li><li><code>rowbuffer::AbstractMatrix{K}</code>: Buffer for V factors, size <code>(maxrank, length(colidcs))</code></li><li><code>rows::Vector{Int}</code>: Storage for selected row indices</li><li><code>cols::Vector{Int}</code>: Storage for selected column indices</li><li><code>rowidcs::Vector{Int}</code>: Global row indices of the block to compress</li><li><code>colidcs::Vector{Int}</code>: Global column indices of the block to compress</li><li><code>maxrank::Int</code>: Maximum number of pivots (hard limit on rank)</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Number of pivots computed (≤ maxrank). The approximation is <code>A[rowidcs, colidcs] ≈ colbuffer[:, 1:npivot] * rowbuffer[1:npivot, :]</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L144-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACAᵀ" href="#AdaptiveCrossApproximation.ACAᵀ"><code>AdaptiveCrossApproximation.ACAᵀ</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ACAᵀ{RowPivType,ColPivType,ConvCritType}</code></pre><p>Column-first variant of adaptive cross approximation. Starts by selecting columns first, then rows. Dual of standard ACA.</p><p><strong>Fields</strong></p><ul><li><code>rowpivoting::RowPivType</code>: Strategy for selecting row pivots</li><li><code>columnpivoting::ColPivType</code>: Strategy for selecting column pivots</li><li><code>convergence::ConvCritType</code>: Convergence criterion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/acaT.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACAᵀ-Tuple{AbstractArray{Int64}, AbstractArray{Int64}}" href="#AdaptiveCrossApproximation.ACAᵀ-Tuple{AbstractArray{Int64}, AbstractArray{Int64}}"><code>AdaptiveCrossApproximation.ACAᵀ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(aca::ACAᵀ)(rowidcs::AbstractArray{Int}, colidcs::AbstractArray{Int})</code></pre><p>Initialize ACAᵀ functor with index sets. Creates functors for pivoting strategies bound to specific index ranges.</p><p><strong>Arguments</strong></p><ul><li><code>rowidcs::AbstractArray{Int}</code>: Row indices for this compression</li><li><code>colidcs::AbstractArray{Int}</code>: Column indices for this compression</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/acaT.jl#L44-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACAᵀ-Tuple{}" href="#AdaptiveCrossApproximation.ACAᵀ-Tuple{}"><code>AdaptiveCrossApproximation.ACAᵀ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ACAᵀ(; rowpivoting=MaximumValue(), columnpivoting=MaximumValue(), convergence=FNormEstimator(1e-4))</code></pre><p>Construct column-first ACA compressor with specified strategies.</p><p><strong>Arguments</strong></p><ul><li><code>rowpivoting</code>: Row pivoting strategy (default: <code>MaximumValue()</code>)</li><li><code>columnpivoting</code>: Column pivoting strategy (default: <code>MaximumValue()</code>)</li><li><code>convergence</code>: Convergence criterion (default: <code>FNormEstimator(1e-4)</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/acaT.jl#L25-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACAᵀ-Union{Tuple{C}, Tuple{P}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, P&lt;:AdaptiveCrossApproximation.PivStrat, C&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.ACAᵀ-Union{Tuple{C}, Tuple{P}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, P&lt;:AdaptiveCrossApproximation.PivStrat, C&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.ACAᵀ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(aca::ACAᵀ{P,P,C})(A, colbuffer, rowbuffer, maxrank; kwargs...)</code></pre><p>Convenience method that initializes pivoting functors when using uniform strategies.</p><p>Delegates to the main computational routine after creating index-specialized functors. Only available when both pivoting strategies are of the same stateless type <code>P &lt;: PivStrat</code>.</p><p>See the main <code>(aca::ACAᵀ)(A, colbuffer, rowbuffer, rows, cols, rowidcs, colidcs, maxrank)</code> method for detailed argument documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/acaT.jl#L59-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ACAᵀ-Union{Tuple{T}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, T, T, T, T, Int64}} where {K, T&lt;:Vector{Int64}}" href="#AdaptiveCrossApproximation.ACAᵀ-Union{Tuple{T}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, T, T, T, T, Int64}} where {K, T&lt;:Vector{Int64}}"><code>AdaptiveCrossApproximation.ACAᵀ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(aca::ACAᵀ)(A, colbuffer, rowbuffer, maxrank; rows, cols, rowidcs, colidcs)</code></pre><p>Perform column-first ACA compression. Computes low-rank approximation A ≈ colbuffer * rowbuffer by iteratively selecting columns then rows.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>colbuffer::AbstractMatrix{K}</code>: Pre-allocated column storage (nrows × maxrank)</li><li><code>rowbuffer::AbstractMatrix{K}</code>: Pre-allocated row storage (maxrank × ncols)</li><li><code>maxrank::Int</code>: Maximum number of pivots</li><li><code>rows</code>: Selected row indices (optional, pre-allocated)</li><li><code>cols</code>: Selected column indices (optional, pre-allocated)</li><li><code>rowidcs</code>: Active row index range (optional)</li><li><code>colidcs</code>: Active column index range (optional)</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Number of pivots computed</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/acaT.jl#L85-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedConvCrit" href="#AdaptiveCrossApproximation.CombinedConvCrit"><code>AdaptiveCrossApproximation.CombinedConvCrit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedConvCrit</code></pre><p>Composite convergence criterion combining multiple criteria. Converges when any constituent criterion is satisfied.</p><p><strong>Fields</strong></p><ul><li><code>crits::Vector{ConvCrit}</code>: Vector of convergence criteria to combine</li><li><code>isconverged::Vector{Bool}</code>: Convergence status for each criterion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/combinedconvcrit.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedConvCrit-Tuple{AbstractMatrix, AbstractArray{Int64}, AbstractArray{Int64}}" href="#AdaptiveCrossApproximation.CombinedConvCrit-Tuple{AbstractMatrix, AbstractArray{Int64}, AbstractArray{Int64}}"><code>AdaptiveCrossApproximation.CombinedConvCrit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::CombinedConvCrit)(K::AbstractMatrix, rowidcs, colidcs)</code></pre><p>Initialize combined criterion functors. Handles special initialization for sampling-based criteria.</p><p><strong>Arguments</strong></p><ul><li><code>K::AbstractMatrix</code>: Matrix to compress</li><li><code>rowidcs::AbstractArray{Int}</code>: Active row indices</li><li><code>colidcs::AbstractArray{Int}</code>: Active column indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/combinedconvcrit.jl#L67-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedConvCritFunctor" href="#AdaptiveCrossApproximation.CombinedConvCritFunctor"><code>AdaptiveCrossApproximation.CombinedConvCritFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedConvCritFunctor</code></pre><p>Stateful convergence criterion combining multiple criteria. Converges when all criteria are satisfied.</p><p><strong>Fields</strong></p><ul><li><code>crits::Vector{ConvCritFunctor}</code>: Vector of convergence criteria to combine</li><li><code>isconverged::Vector{Bool}</code>: Convergence status for each criterion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/combinedconvcrit.jl#L16-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedConvCritFunctor-Union{Tuple{K}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where K" href="#AdaptiveCrossApproximation.CombinedConvCritFunctor-Union{Tuple{K}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where K"><code>AdaptiveCrossApproximation.CombinedConvCritFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::CombinedConvCritFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)</code></pre><p>Check convergence using all combined criteria. Returns when any criterion signals convergence.</p><p><strong>Arguments</strong></p><ul><li><code>rowbuffer::AbstractMatrix{K}</code>: Row factor buffer</li><li><code>colbuffer::AbstractMatrix{K}</code>: Column factor buffer</li><li><code>npivot::Int</code>: Current pivot index</li><li><code>maxrows::Int</code>: Number of active rows</li><li><code>maxcolumns::Int</code>: Number of active columns</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Final pivot count</li><li><code>continue::Bool</code>: Whether to continue iteration (true if any criterion satisfied)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/combinedconvcrit.jl#L32-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedPivStrat" href="#AdaptiveCrossApproximation.CombinedPivStrat"><code>AdaptiveCrossApproximation.CombinedPivStrat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedPivStrat</code></pre><p>Composite pivoting strategy that switches between multiple strategies based on convergence.</p><p>Combines multiple pivoting strategies with a combined convergence criterion, allowing the pivot selection method to change as different convergence criteria are satisfied. For example, can start with geometric pivoting and switch to value-based pivoting once a certain accuracy is reached.</p><p><strong>Fields</strong></p><ul><li><code>strats::Vector{PivStrat}</code>: Ordered list of pivoting strategies to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/combinedpivstrat.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedPivStrat-Tuple{AdaptiveCrossApproximation.CombinedConvCritFunctor, AbstractArray{Int64}}" href="#AdaptiveCrossApproximation.CombinedPivStrat-Tuple{AdaptiveCrossApproximation.CombinedConvCritFunctor, AbstractArray{Int64}}"><code>AdaptiveCrossApproximation.CombinedPivStrat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::CombinedPivStrat)(convergence::CombinedConvCritFunctor, idcs::AbstractArray{Int})</code></pre><p>Create a combined pivoting functor for the given index subset.</p><p>Initializes all constituent strategies with the provided indices and links them to the combined convergence criterion. Handles special cases like <code>RandomSamplingPivoting</code> which requires the convergence criterion functor rather than indices.</p><p><strong>Arguments</strong></p><ul><li><code>convergence::CombinedConvCritFunctor</code>: Combined convergence criterion</li><li><code>idcs::AbstractArray{Int}</code>: Indices for the submatrix</li></ul><p><strong>Returns</strong></p><ul><li><code>CombinedPivStratFunctor</code>: Initialized combined strategy with functors for all sub-strategies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/combinedpivstrat.jl#L83-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedPivStratFunctor" href="#AdaptiveCrossApproximation.CombinedPivStratFunctor"><code>AdaptiveCrossApproximation.CombinedPivStratFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CombinedPivStratFunctor</code></pre><p>Staeful functor of composite pivoting strategy that switches between multiple strategies based on convergence.</p><p>Combines multiple pivoting strategies with a combined convergence criterion, allowing the pivot selection method to change as different convergence criteria are satisfied. For example, can start with geometric pivoting and switch to value-based pivoting once a certain accuracy is reached.</p><p><strong>Fields</strong></p><ul><li><code>convcrit::CombinedConvCritFunctor</code>: Combined convergence criterion tracking which sub-criteria are met</li><li><code>strats::Vector{PivStratFunctor}</code>: Ordered list of pivoting strategies to use</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/combinedpivstrat.jl#L20-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedPivStratFunctor-Tuple{AbstractArray}" href="#AdaptiveCrossApproximation.CombinedPivStratFunctor-Tuple{AbstractArray}"><code>AdaptiveCrossApproximation.CombinedPivStratFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::CombinedPivStratFunctor)(rc::AbstractArray)</code></pre><p>Select next pivot using the first strategy whose convergence criterion is met.</p><p>Iterates through the convergence criteria and uses the strategy corresponding to the first satisfied criterion. If no criteria are met, uses the first strategy. Automatically updates the convergence tracking state.</p><p><strong>Arguments</strong></p><ul><li><code>rc::AbstractArray</code>: Row or column data for pivot selection</li></ul><p><strong>Returns</strong></p><ul><li>Pivot index selected by the active strategy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/combinedpivstrat.jl#L56-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.CombinedPivStratFunctor-Tuple{}" href="#AdaptiveCrossApproximation.CombinedPivStratFunctor-Tuple{}"><code>AdaptiveCrossApproximation.CombinedPivStratFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::CombinedPivStratFunctor)()</code></pre><p>Select initial pivot using the first strategy.</p><p>Delegates to the first strategy in the list for initial pivot selection when no data is available yet.</p><p><strong>Returns</strong></p><ul><li>Initial pivot index from the first strategy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/combinedpivstrat.jl#L40-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ConvCrit" href="#AdaptiveCrossApproximation.ConvCrit"><code>AdaptiveCrossApproximation.ConvCrit</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvCrit</code></pre><p>Abstract base type for convergence criteria. Convergence criteria determine when to stop the ACA iteration based on approximation quality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/abstractconvergence.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ConvCritFunctor" href="#AdaptiveCrossApproximation.ConvCritFunctor"><code>AdaptiveCrossApproximation.ConvCritFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvCritFunctor</code></pre><p>Abstract base type for stateful convergence criterion functors. Used during compression to track convergence state across iterations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/abstractconvergence.jl#L9-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ConvPivStrat" href="#AdaptiveCrossApproximation.ConvPivStrat"><code>AdaptiveCrossApproximation.ConvPivStrat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvPivStrat &lt;: PivStrat</code></pre><p>Abstract type for convergence-driven pivoting strategies.</p><p>These strategies adapt their behavior based on convergence information or use randomization to improve robustness.</p><p><strong>Concrete Types</strong></p><ul><li><a href="#AdaptiveCrossApproximation.RandomSampling"><code>RandomSampling</code></a>: Random pivot selection for convergence estimation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L74-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ConvPivStratFunctor" href="#AdaptiveCrossApproximation.ConvPivStratFunctor"><code>AdaptiveCrossApproximation.ConvPivStratFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConvPivStratFunctor &lt;: PivStratFunctor</code></pre><p>Abstract type for stateful convergence-driven pivoting functors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormEstimator" href="#AdaptiveCrossApproximation.FNormEstimator"><code>AdaptiveCrossApproximation.FNormEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FNormEstimator{F} &lt;: ConvCrit</code></pre><p>Frobenius norm-based convergence criterion for standard ACA.</p><p><strong>Fields</strong></p><ul><li><code>tol::F</code>: Relative tolerance threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormEstimator-Union{Tuple{}, Tuple{F}} where F" href="#AdaptiveCrossApproximation.FNormEstimator-Union{Tuple{}, Tuple{F}} where F"><code>AdaptiveCrossApproximation.FNormEstimator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(cc::FNormEstimator{F})()</code></pre><p>Initialize FNormEstimator functor with zero accumulated norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L30-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormEstimatorFunctor" href="#AdaptiveCrossApproximation.FNormEstimatorFunctor"><code>AdaptiveCrossApproximation.FNormEstimatorFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FNormEstimatorFunctor{F} &lt;: ConvCritFunctor</code></pre><p>Stateful Frobenius norm estimator for ACA compression. Tracks squared norm of UV factorization across iterations and stops iteration when relative error estimate falls below tolerance.</p><p><strong>Fields</strong></p><ul><li><code>normUV²::F</code>: Accumulated squared Frobenius norm of UV</li><li><code>tol::F</code>: Relative tolerance threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L14-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormEstimatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.FNormEstimatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.FNormEstimatorFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::FNormEstimatorFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)</code></pre><p>Check convergence for standard ACA using Frobenius norm estimate. Returns (npivot, continue) where continue is true if iteration should proceed.</p><p><strong>Arguments</strong></p><ul><li><code>rowbuffer::AbstractMatrix{K}</code>: Row factor buffer</li><li><code>colbuffer::AbstractMatrix{K}</code>: Column factor buffer</li><li><code>npivot::Int</code>: Current pivot index</li><li><code>maxrows::Int</code>: Number of active rows</li><li><code>maxcolumns::Int</code>: Number of active columns</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Final pivot count</li><li><code>continue::Bool</code>: Whether to continue iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L46-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormExtrapolator" href="#AdaptiveCrossApproximation.FNormExtrapolator"><code>AdaptiveCrossApproximation.FNormExtrapolator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FNormExtrapolator{F} &lt;: ConvCrit</code></pre><p>Convergence criterion using polynomial extrapolation of pivot norms. Combines norm estimation with quadratic extrapolation to predict convergence.</p><p><strong>Fields</strong></p><ul><li><code>estimator::Union{FNormEstimator{F},iFNormEstimator{F}}</code>: Underlying norm estimator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormExtrapolator-Tuple{F} where F" href="#AdaptiveCrossApproximation.FNormExtrapolator-Tuple{F} where F"><code>AdaptiveCrossApproximation.FNormExtrapolator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FNormExtrapolator(tol::F)</code></pre><p>Construct extrapolator with Frobenius norm estimator.</p><p><strong>Arguments</strong></p><ul><li><code>tol::F</code>: Convergence tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L33-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormExtrapolator-Union{Tuple{}, Tuple{F}} where F" href="#AdaptiveCrossApproximation.FNormExtrapolator-Union{Tuple{}, Tuple{F}} where F"><code>AdaptiveCrossApproximation.FNormExtrapolator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(cc::FNormExtrapolator{F})()</code></pre><p>Initialize extrapolator functor with empty history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormExtrapolatorFunctor" href="#AdaptiveCrossApproximation.FNormExtrapolatorFunctor"><code>AdaptiveCrossApproximation.FNormExtrapolatorFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FNormExtrapolatorFunctor{F} &lt;: ConvCritFunctor</code></pre><p>Stateful extrapolator tracking pivot norm history. Fits quadratic polynomial to log-scaled norms for convergence prediction.</p><p><strong>Fields</strong></p><ul><li><code>lastnorms::Vector{F}</code>: History of pivot norms for extrapolation</li><li><code>estimator::Union{FNormEstimatorFunctor{F},iFNormEstimatorFunctor{F}}</code>: Active estimator functor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormExtrapolatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.FNormExtrapolatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.FNormExtrapolatorFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::FNormExtrapolatorFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)</code></pre><p>Check convergence for ACA using extrapolation. Fits quadratic to log-norms and extrapolates to predict convergence.</p><p><strong>Arguments</strong></p><ul><li><code>rowbuffer::AbstractMatrix{K}</code>: Row factor buffer</li><li><code>colbuffer::AbstractMatrix{K}</code>: Column factor buffer</li><li><code>npivot::Int</code>: Current pivot index</li><li><code>maxrows::Int</code>: Number of active rows</li><li><code>maxcolumns::Int</code>: Number of active columns</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Final pivot count</li><li><code>continue::Bool</code>: Whether to continue iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L62-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FNormExtrapolatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractVector{K}, Int64}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.FNormExtrapolatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractVector{K}, Int64}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.FNormExtrapolatorFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::FNormExtrapolatorFunctor)(rcbuffer::AbstractVector{K}, npivot::Int)</code></pre><p>Check convergence for iACA using extrapolation. Applies extrapolation to incomplete ACA norm history.</p><p><strong>Arguments</strong></p><ul><li><code>rcbuffer::AbstractVector{K}</code>: Current row or column buffer</li><li><code>npivot::Int</code>: Current pivot index</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Final pivot count</li><li><code>continue::Bool</code>: Whether to continue iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L103-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FillDistance" href="#AdaptiveCrossApproximation.FillDistance"><code>AdaptiveCrossApproximation.FillDistance</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FillDistance{D,F&lt;:Real} &lt;: GeoPivStrat</code></pre><p>Geometric pivoting strategy based on fill distance minimization.</p><p>Selects pivots to minimize the fill distance, promoting well-distributed sampling in geometric space.</p><p><strong>Fields</strong></p><ul><li><code>pos::Vector{SVector{D,F}}</code>: Geometric positions of all points (D-dimensional)</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>D</code>: Spatial dimension</li><li><code>F</code>: Floating point type for coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/filldistance.jl#L2-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FillDistance-Union{Tuple{AbstractArray{Int64}}, Tuple{F}, Tuple{D}} where {D, F}" href="#AdaptiveCrossApproximation.FillDistance-Union{Tuple{AbstractArray{Int64}}, Tuple{F}, Tuple{D}} where {D, F}"><code>AdaptiveCrossApproximation.FillDistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::FillDistance{D,F})(idcs::AbstractArray{Int})</code></pre><p>Create a <code>FillDistanceFunctor</code> for the given index subset.</p><p>Initializes the functor with positions corresponding to <code>idcs</code>, preparing it for pivot selection within the submatrix.</p><p><strong>Arguments</strong></p><ul><li><code>idcs::AbstractArray{Int}</code>: Indices of points to consider</li></ul><p><strong>Returns</strong></p><ul><li><code>FillDistanceFunctor</code>: Initialized functor with distance tracking</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/filldistance.jl#L41-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FillDistanceFunctor" href="#AdaptiveCrossApproximation.FillDistanceFunctor"><code>AdaptiveCrossApproximation.FillDistanceFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FillDistanceFunctor{D,F&lt;:Real} &lt;: PivStratFunctor</code></pre><p>Stateful functor for fill distance pivot selection.</p><p>Maintains the minimum distances from each point to the set of selected points, updating them as new pivots are chosen.</p><p><strong>Fields</strong></p><ul><li><code>h::Vector{F}</code>: Current minimum distance from each point to selected points</li><li><code>pos::Vector{SVector{D,F}}</code>: Geometric positions corresponding to indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/filldistance.jl#L22-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.FillDistanceFunctor-Union{Tuple{AbstractArray}, Tuple{F}, Tuple{D}} where {D, F}" href="#AdaptiveCrossApproximation.FillDistanceFunctor-Union{Tuple{AbstractArray}, Tuple{F}, Tuple{D}} where {D, F}"><code>AdaptiveCrossApproximation.FillDistanceFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::FillDistanceFunctor{D,F})(::AbstractArray)</code></pre><p>Select the next pivot minimizing the fill distance with respect to the selected points and updates the distance vector <code>h</code> for subsequent iterations.</p><p><strong>Arguments</strong></p><ul><li><code>::AbstractArray</code>: Row/column data (unused, selection is purely geometric)</li></ul><p><strong>Returns</strong></p><ul><li><code>nextidx::Int</code>: Index of the point maximizing fill distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/filldistance.jl#L76-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.GeoPivStrat" href="#AdaptiveCrossApproximation.GeoPivStrat"><code>AdaptiveCrossApproximation.GeoPivStrat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoPivStrat &lt;: PivStrat</code></pre><p>Abstract type for geometric/spatial pivoting strategies.</p><p>These strategies select pivots based on spatial/geometric properties rather than matrix values. Useful when geometric information about rows/columns is available.</p><p><strong>Concrete Types</strong></p><ul><li><a href="#AdaptiveCrossApproximation.FillDistance"><code>FillDistance</code></a>: Maximizes minimum distance to already selected points</li><li><a href="#AdaptiveCrossApproximation.Leja2"><code>Leja2</code></a>: Maximizes product of distances to selected points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L44-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.GeoPivStratFunctor" href="#AdaptiveCrossApproximation.GeoPivStratFunctor"><code>AdaptiveCrossApproximation.GeoPivStratFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeoPivStratFunctor &lt;: PivStratFunctor</code></pre><p>Abstract type for stateful geometric pivoting functors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L88-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.Leja2" href="#AdaptiveCrossApproximation.Leja2"><code>AdaptiveCrossApproximation.Leja2</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Leja2{D,F&lt;:Real} &lt;: GeoPivStrat</code></pre><p>Geometric pivoting strategy based on Leja points (product of distances).</p><p>A modified more efficient version of the fill distance approach. This leads to well-separated point sequences. These points have been introduced as modified leja points and will, therefore, be referred to as Leja2 points within this package.</p><p><strong>Fields</strong></p><ul><li><code>pos::Vector{SVector{D,F}}</code>: Geometric positions of all points (D-dimensional)</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>D</code>: Spatial dimension</li><li><code>F</code>: Floating point type for coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/lejapoints.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.Leja2-Union{Tuple{AbstractArray{Int64}}, Tuple{F}, Tuple{D}} where {D, F}" href="#AdaptiveCrossApproximation.Leja2-Union{Tuple{AbstractArray{Int64}}, Tuple{F}, Tuple{D}} where {D, F}"><code>AdaptiveCrossApproximation.Leja2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::Leja2{D,F})(idcs::AbstractArray{Int})</code></pre><p>Create a <code>Leja2Functor</code> for the given index subset.</p><p>Initializes the functor with positions corresponding to <code>idcs</code>, preparing it for pivot selection within the submatrix.</p><p><strong>Arguments</strong></p><ul><li><code>idcs::AbstractArray{Int}</code>: Indices of points to consider</li></ul><p><strong>Returns</strong></p><ul><li><code>Leja2Functor</code>: Initialized functor with distance tracking</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/lejapoints.jl#L45-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.Leja2Functor" href="#AdaptiveCrossApproximation.Leja2Functor"><code>AdaptiveCrossApproximation.Leja2Functor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Leja2Functor{D,F&lt;:Real} &lt;: PivStratFunctor</code></pre><p>Stateful functor for modified leja point pivot selection.</p><p>Maintains minimum distances from each point to all selected points, which are updated incrementally as new pivots are chosen.</p><p><strong>Fields</strong></p><ul><li><code>h::Vector{F}</code>: Current minimum distance from each point to selected points</li><li><code>idcs::Vector{Int}</code>: Indices of points being considered for selection</li><li><code>pos::Vector{SVector{D,F}}</code>: Geometric positions corresponding to indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/lejapoints.jl#L25-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.Leja2Functor-Union{Tuple{AbstractArray}, Tuple{F}, Tuple{D}} where {D, F}" href="#AdaptiveCrossApproximation.Leja2Functor-Union{Tuple{AbstractArray}, Tuple{F}, Tuple{D}} where {D, F}"><code>AdaptiveCrossApproximation.Leja2Functor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::Leja2Functor{D,F})(::AbstractArray)</code></pre><p>Select the next pivot with maximum minimum distance to selected points.</p><p>Chooses the point that is farthest from the set of already selected points, then updates the distance vector for subsequent iterations.</p><p><strong>Arguments</strong></p><ul><li><code>::AbstractArray</code>: Row/column data (unused, selection is purely geometric)</li></ul><p><strong>Returns</strong></p><ul><li><code>nextidx::Int</code>: Index of the point with maximum distance to selected points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/lejapoints.jl#L87-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MaximumValue" href="#AdaptiveCrossApproximation.MaximumValue"><code>AdaptiveCrossApproximation.MaximumValue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaximumValue &lt;: ValuePivStrat</code></pre><p>Pivoting strategy that selects the index with maximum absolute value.</p><p>This is the standard pivoting strategy used in classical ACA algorithms also referred to as partial pivoting. At each iteration, it chooses the row or column with the largest absolute value among the unused indices, ensuring numerical stability and good approximation quality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/maxvalue.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MaximumValue-Tuple{AbstractArray{Int64}}" href="#AdaptiveCrossApproximation.MaximumValue-Tuple{AbstractArray{Int64}}"><code>AdaptiveCrossApproximation.MaximumValue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(::MaximumValue)(idcs::AbstractArray{Int})</code></pre><p>Create a <code>MaximumValueFunctor</code> for the given index array.</p><p>Returns a functor with tracking vector sized to match the length of <code>idcs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/maxvalue.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MaximumValueFunctor" href="#AdaptiveCrossApproximation.MaximumValueFunctor"><code>AdaptiveCrossApproximation.MaximumValueFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MaximumValueFunctor &lt;: ValuePivStratFunctor</code></pre><p>Stateful functor that tracks which indices have been used during pivot selection.</p><p>Created by calling a <a href="#AdaptiveCrossApproximation.MaximumValue"><code>MaximumValue</code></a> instance with length or index information. Maintains a boolean vector to ensure each index is selected at most once.</p><p><strong>Fields</strong></p><ul><li><code>usedidcs::Vector{Bool}</code>: Tracks which indices have been selected as pivots</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/maxvalue.jl#L14-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MaximumValueFunctor-Tuple{AbstractArray}" href="#AdaptiveCrossApproximation.MaximumValueFunctor-Tuple{AbstractArray}"><code>AdaptiveCrossApproximation.MaximumValueFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::MaximumValueFunctor)(rc::AbstractArray)</code></pre><p>Select the unused index with maximum absolute value in <code>rc</code>.</p><p>Searches through all unused indices, finds the one with largest <code>abs(rc[i])</code>, marks it as used, and returns its index.</p><p><strong>Arguments</strong></p><ul><li><code>rc::AbstractArray</code>: Row or column data to select from</li></ul><p><strong>Returns</strong></p><ul><li><code>nextidx::Int</code>: Index of the maximum absolute value among unused indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/maxvalue.jl#L51-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MaximumValueFunctor-Tuple{}" href="#AdaptiveCrossApproximation.MaximumValueFunctor-Tuple{}"><code>AdaptiveCrossApproximation.MaximumValueFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::MaximumValueFunctor)()</code></pre><p>Select the first index as the initial pivot.</p><p>Returns <code>1</code> and marks it as used. Used when no row/column data is available yet.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/maxvalue.jl#L39-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MimicryPivoting" href="#AdaptiveCrossApproximation.MimicryPivoting"><code>AdaptiveCrossApproximation.MimicryPivoting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MimicryPivoting{D,F&lt;:Real} &lt;: GeoPivStrat</code></pre><p>Geometric pivoting strategy that mimics point distribution of a fully pivoted ACA geometrically.</p><p>Selects pivots to reproduce the spatial distribution of a fully pivoted ACA. The strategy balances three objectives: geometric separation (Leja-like behavior), proximity to the reference distribution, and fill distance maximization. Particularly useful for H²–matrix compression where incomplete factorizations are sufficient.</p><p><strong>Fields</strong></p><ul><li><code>refpos::Vector{SVector{D,F}}</code>: Positions of test or expansion domain</li><li><code>pos::Vector{SVector{D,F}}</code>: Positions from which to select pivots</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>D</code>: Spatial dimension</li><li><code>F</code>: Floating point type for coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/mimicrypivoting.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MimicryPivoting-Union{Tuple{F}, Tuple{D}, Tuple{Any, Any}} where {D, F}" href="#AdaptiveCrossApproximation.MimicryPivoting-Union{Tuple{F}, Tuple{D}, Tuple{Any, Any}} where {D, F}"><code>AdaptiveCrossApproximation.MimicryPivoting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(strat::MimicryPivoting{D,F})(refidcs, rcidcs)</code></pre><p>Create a <code>MimicryPivotingFunctor</code> for the given reference and candidate indices.</p><p>Initializes the functor by computing the centroid of the reference points and setting up weights that favor points close to this centroid. This encourages the selected pivots to spatially mimic the reference distribution.</p><p><strong>Arguments</strong></p><ul><li><code>refidcs</code>: Indices of reference points (e.g., parent cluster pivots)</li><li><code>rcidcs</code>: Indices of candidate points to select from (e.g., child cluster points)</li></ul><p><strong>Returns</strong></p><ul><li><code>MimicryPivotingFunctor</code>: Initialized functor with computed weights and metrics</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/mimicrypivoting.jl#L50-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MimicryPivotingFunctor" href="#AdaptiveCrossApproximation.MimicryPivotingFunctor"><code>AdaptiveCrossApproximation.MimicryPivotingFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MimicryPivotingFunctor{D,F&lt;:Real} &lt;: GeoPivStratFunctor</code></pre><p>Functor for mimicry-based pivot selection.</p><p>Maintains vectors for leja2 (h), leja (leja), and weights (w) based on distance to reference centroid.</p><p><strong>Fields</strong></p><ul><li><code>pos::Vector{SVector{D,F}}</code>: All geometric positions</li><li><code>idcs::Vector{Int}</code>: Current indices being considered for selection</li><li><code>h::Vector{F}</code>: Minimum distances from each point to selected points (fill distance)</li><li><code>leja::Vector{F}</code>: Product of distances to all selected points (Leja metric)</li><li><code>w::Vector{F}</code>: Weights based on inverse distance to reference centroid</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/mimicrypivoting.jl#L27-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MimicryPivotingFunctor-Union{Tuple{Int64}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}" href="#AdaptiveCrossApproximation.MimicryPivotingFunctor-Union{Tuple{Int64}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}"><code>AdaptiveCrossApproximation.MimicryPivotingFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(strat::MimicryPivotingFunctor{D,F})(npivot::Int)</code></pre><p>Select next pivot balancing Leja separation, fill distance, and reference proximity.</p><p>Uses a composite metric that combines:</p><ul><li>Leja product (geometric separation from all selected points)</li><li>Fill distance (maximum minimum distance criterion)</li><li>Reference weights (proximity to target distribution)</li></ul><p>The balance between these factors evolves with iteration number <code>npivot</code>.</p><p><strong>Arguments</strong></p><ul><li><code>npivot::Int</code>: Current pivot iteration number (influences weight balance)</li></ul><p><strong>Returns</strong></p><ul><li>Global index of the selected pivot point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/mimicrypivoting.jl#L96-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.MimicryPivotingFunctor-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}" href="#AdaptiveCrossApproximation.MimicryPivotingFunctor-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}"><code>AdaptiveCrossApproximation.MimicryPivotingFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(strat::MimicryPivotingFunctor{D,F})()</code></pre><p>Select the first pivot based on proximity to reference centroid.</p><p>Chooses the point with maximum weight (closest to the reference centroid), then initializes distance metrics for subsequent pivot selection.</p><p><strong>Returns</strong></p><ul><li>Global index of the selected pivot point</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/mimicrypivoting.jl#L77-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.PivStrat" href="#AdaptiveCrossApproximation.PivStrat"><code>AdaptiveCrossApproximation.PivStrat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PivStrat</code></pre><p>Abstract base type for pivoting strategies in cross approximation algorithms.</p><p>Pivoting strategies determine which row or column to select at each iteration of the ACA algorithm. Concrete subtypes are typically stateless and callable, creating stateful <a href="#AdaptiveCrossApproximation.PivStratFunctor"><code>PivStratFunctor</code></a> instances when invoked with index information.</p><p><strong>Subtypes by Category</strong></p><ul><li><a href="#AdaptiveCrossApproximation.GeoPivStrat"><code>GeoPivStrat</code></a>: Geometric strategies (e.g., fill distance, Leja points)</li><li><a href="#AdaptiveCrossApproximation.ValuePivStrat"><code>ValuePivStrat</code></a>: Value-based strategies (e.g., maximum absolute value)</li><li><a href="#AdaptiveCrossApproximation.ConvPivStrat"><code>ConvPivStrat</code></a>: Convergence-driven strategies (e.g., random sampling)</li></ul><p><strong>Interface</strong></p><p>Concrete subtypes should implement:</p><ul><li><code>(strategy::MyPivStrat)(len::Int)</code>: Create functor for <code>len</code> indices</li><li><code>(strategy::MyPivStrat)(idcs::AbstractArray{Int})</code>: Create functor for index array</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.PivStratFunctor" href="#AdaptiveCrossApproximation.PivStratFunctor"><code>AdaptiveCrossApproximation.PivStratFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PivStratFunctor</code></pre><p>Abstract base type for stateful pivoting functors.</p><p>Functors maintain state during the pivot selection process (e.g., tracking which indices have been used). Created by calling a <a href="#AdaptiveCrossApproximation.PivStrat"><code>PivStrat</code></a> instance with index information.</p><p><strong>Interface</strong></p><p>Concrete subtypes should implement:</p><ul><li><code>(functor::MyPivStratFunctor)()</code>: Select initial pivot (no data available)</li><li><code>(functor::MyPivStratFunctor)(rc::AbstractArray)</code>: Select next pivot based on row/column data</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L25-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSampling" href="#AdaptiveCrossApproximation.RandomSampling"><code>AdaptiveCrossApproximation.RandomSampling</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomSampling{F&lt;:Real} &lt;: ConvCrit</code></pre><p>Convergence criterion based on random matrix entry sampling. Monitors approximation error at randomly sampled positions.</p><p><strong>Fields</strong></p><ul><li><code>nsamples::Int</code>: Number of random samples to take</li><li><code>factor::F</code>: Factor for automatic sample count (nsamples = factor * (nrows + ncols))</li><li><code>tol::F</code>: Convergence tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/randomsampling.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSampling-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{Int64}, AbstractArray{Int64}}} where T" href="#AdaptiveCrossApproximation.RandomSampling-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractArray{Int64}, AbstractArray{Int64}}} where T"><code>AdaptiveCrossApproximation.RandomSampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(cc::RandomSampling)(K::AbstractMatrix{T}, rowidcs, colidcs)</code></pre><p>Initialize random sampling functor with sampled matrix entries.</p><p><strong>Arguments</strong></p><ul><li><code>K::AbstractMatrix{T}</code>: Matrix to compress</li><li><code>rowidcs::AbstractArray{Int}</code>: Active row indices</li><li><code>colidcs::AbstractArray{Int}</code>: Active column indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/randomsampling.jl#L54-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSampling-Union{Tuple{}, Tuple{F}} where F&lt;:Real" href="#AdaptiveCrossApproximation.RandomSampling-Union{Tuple{}, Tuple{F}} where F&lt;:Real"><code>AdaptiveCrossApproximation.RandomSampling</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">RandomSampling(; factor=1.0, nsamples=0, tol=1e-4)</code></pre><p>Construct random sampling convergence criterion.</p><p><strong>Arguments</strong></p><ul><li><code>factor::F</code>: Multiplier for automatic sample count (default: <code>1.0</code>)</li><li><code>nsamples::Int</code>: Fixed sample count (default: <code>0</code>, use factor instead)</li><li><code>tol::F</code>: Convergence tolerance (default: <code>1e-4</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/randomsampling.jl#L39-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSamplingFunctor" href="#AdaptiveCrossApproximation.RandomSamplingFunctor"><code>AdaptiveCrossApproximation.RandomSamplingFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomSamplingFunctor{F&lt;:Real,K} &lt;: ConvCritFunctor</code></pre><p>Stateful random sampling convergence checker. Tracks residual error at sampled matrix entries across iterations.</p><p><strong>Fields</strong></p><ul><li><code>normUV²::F</code>: Squared Frobenius norm of approximation</li><li><code>indices::Matrix{Int}</code>: Sampled matrix positions (nsamples × 2)</li><li><code>rest::Vector{K}</code>: Residual values at sampled positions</li><li><code>tol::F</code>: Convergence tolerance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/randomsampling.jl#L19-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSamplingFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.RandomSamplingFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.RandomSamplingFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::RandomSamplingFunctor)(rowbuffer, colbuffer, npivot, maxrows, maxcolumns)</code></pre><p>Check convergence using random sampling. Updates residuals at sampled positions and compares to tolerance.</p><p><strong>Arguments</strong></p><ul><li><code>rowbuffer::AbstractMatrix{K}</code>: Row factor buffer</li><li><code>colbuffer::AbstractMatrix{K}</code>: Column factor buffer</li><li><code>npivot::Int</code>: Current pivot index</li><li><code>maxrows::Int</code>: Number of active rows</li><li><code>maxcolumns::Int</code>: Number of active columns</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Final pivot count</li><li><code>continue::Bool</code>: Whether to continue iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/randomsampling.jl#L83-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSamplingPivoting" href="#AdaptiveCrossApproximation.RandomSamplingPivoting"><code>AdaptiveCrossApproximation.RandomSamplingPivoting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomSamplingPivoting &lt;: ConvPivStrat</code></pre><p>Pivoting strategy that uses the error of random sampling from the convergence estimation.</p><p>Instead of selecting pivots based on maximum values or geometric properties, this strategy chooses pivots from randomly sampled indices used by a random sampling convergence criterion. Works in conjunction with <a href="#AdaptiveCrossApproximation.RandomSamplingFunctor"><code>RandomSamplingFunctor</code></a> to provide statistically based pivot selection.</p><p><strong>Fields</strong></p><ul><li><code>rc::Int</code>: Index indicating which coordinate (row=1 or column=2) to select from</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/randomsampling.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSamplingPivoting-Union{Tuple{AdaptiveCrossApproximation.RandomSamplingFunctor{F, K}}, Tuple{K}, Tuple{F}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.RandomSamplingPivoting-Union{Tuple{AdaptiveCrossApproximation.RandomSamplingFunctor{F, K}}, Tuple{K}, Tuple{F}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.RandomSamplingPivoting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::RandomSamplingPivoting)(convcrit::RandomSamplingFunctor{F,K})</code></pre><p>Create a <code>RandomSamplingPivotingFunctor</code> linked to the convergence criterion.</p><p>Initializes the functor by connecting it to the random sampling convergence criterion that tracks sampled indices and residuals.</p><p><strong>Arguments</strong></p><ul><li><code>convcrit::RandomSamplingFunctor{F,K}</code>: Random sampling convergence functor</li></ul><p><strong>Returns</strong></p><ul><li><code>RandomSamplingPivotingFunctor</code>: Initialized functor linked to the criterion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/randomsampling.jl#L67-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSamplingPivotingFunctor" href="#AdaptiveCrossApproximation.RandomSamplingPivotingFunctor"><code>AdaptiveCrossApproximation.RandomSamplingPivotingFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomSamplingPivotingFunctor{F,K} &lt;: ConvPivStratFunctor</code></pre><p>Stateful functor for random sampling-based pivot selection.</p><p>Links to a random sampling convergence criterion functor to access the randomly sampled indices and their residuals, selecting pivots from the worst-performing samples.</p><p><strong>Fields</strong></p><ul><li><code>convcrit::RandomSamplingFunctor{F,K}</code>: Convergence criterion with sample information</li><li><code>rc::Int</code>: Coordinate index (1 for row, 2 for column)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/randomsampling.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.RandomSamplingPivotingFunctor-Union{Tuple{AbstractArray}, Tuple{K}, Tuple{F}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.RandomSamplingPivotingFunctor-Union{Tuple{AbstractArray}, Tuple{K}, Tuple{F}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.RandomSamplingPivotingFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::RandomSamplingPivotingFunctor{F,K})(::AbstractArray)</code></pre><p>Select pivot from the sample with largest residual.</p><p>Examines the random samples tracked by the convergence criterion and returns the row or column index (depending on <code>rc</code>) corresponding to the sample with the maximum residual error.</p><p><strong>Arguments</strong></p><ul><li><code>::AbstractArray</code>: Row/column data (unused, selection based on random samples)</li></ul><p><strong>Returns</strong></p><ul><li>Index from the worst-performing random sample</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/randomsampling.jl#L46-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.TreeMimicryPivoting" href="#AdaptiveCrossApproximation.TreeMimicryPivoting"><code>AdaptiveCrossApproximation.TreeMimicryPivoting</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeMimicryPivoting{D,T,TreeType} &lt;: GeoPivStrat</code></pre><p>Tree-aware mimicry pivoting strategy.</p><p>This strategy adapts the <code>MimicryPivoting</code> idea to a hierarchical tree of clusters. Instead of selecting individual points directly, it navigates the tree to pick clusters and then nodes within those clusters so that the selected pivots mimic a reference distribution at multiple scales.</p><p><strong>Fields</strong></p><ul><li><code>refpos::Vector{SVector{D,T}}</code>: Reference positions to mimic (e.g., parent pivots)</li><li><code>pos::Vector{SVector{D,T}}</code>: Candidate point positions</li><li><code>tree::TreeType</code>: Tree structure providing cluster centers, children and values</li></ul><p><strong>Type parameters</strong></p><ul><li><code>D</code>: spatial dimension</li><li><code>T</code>: numeric type for coordinates</li><li><code>TreeType</code>: type of the tree adapter (must implement <code>center</code>, <code>values</code>, <code>children</code>, <code>firstchild</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L2-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.TreeMimicryPivoting-Union{Tuple{T}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, T}, 1}, Array{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T&lt;:Real}" href="#AdaptiveCrossApproximation.TreeMimicryPivoting-Union{Tuple{T}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, T}, 1}, Array{StaticArraysCore.SVector{D, T}, 1}, Any}} where {D, T&lt;:Real}"><code>AdaptiveCrossApproximation.TreeMimicryPivoting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TreeMimicryPivoting(refpos, pos, tree)</code></pre><p>Convenience constructor inferring tree type. <code>refpos</code> and <code>pos</code> must be vectors of <code>SVector{D,T}</code> coordinates and <code>tree</code> must provide required methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L34-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.TreeMimicryPivoting-Union{Tuple{V}, Tuple{T}, Tuple{D}, Tuple{V, V, Int64}} where {D, T, V&lt;:Vector{Int64}}" href="#AdaptiveCrossApproximation.TreeMimicryPivoting-Union{Tuple{V}, Tuple{T}, Tuple{D}, Tuple{V, V, Int64}} where {D, T, V&lt;:Vector{Int64}}"><code>AdaptiveCrossApproximation.TreeMimicryPivoting</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::TreeMimicryPivoting)(F, refidcs, maxrank)</code></pre><p>Initialize a tree-aware mimicry functor.</p><p><code>F</code> is a vector of tree node candidates (e.g., root children). The function computes the reference centroid from <code>refidcs</code> and allocates <code>usedidcs</code> of length <code>maxrank</code> for storing selected point indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L73-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.TreeMimicryPivotingFunctor" href="#AdaptiveCrossApproximation.TreeMimicryPivotingFunctor"><code>AdaptiveCrossApproximation.TreeMimicryPivotingFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TreeMimicryPivotingFunctor{D,T,TreeType} &lt;: GeoPivStratFunctor</code></pre><p>Functor storing state for tree-based mimicry pivoting.</p><p><strong>Fields</strong></p><ul><li><code>F::Vector{Int}</code>: Candidate cluster node indices to search</li><li><code>c::SVector{D,T}</code>: Reference centroid used to bias selection</li><li><code>tree::TreeType</code>: Tree providing cluster geometry and membership</li><li><code>pos::Vector{SVector{D,T}}</code>: Point coordinates</li><li><code>usedidcs::Vector{Int}</code>: Selected global point indices (filled progressively)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L46-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.TreeMimicryPivotingFunctor-Union{Tuple{Int64}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}" href="#AdaptiveCrossApproximation.TreeMimicryPivotingFunctor-Union{Tuple{Int64}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}"><code>AdaptiveCrossApproximation.TreeMimicryPivotingFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::TreeMimicryPivotingFunctor)(npivot)</code></pre><p>Select subsequent pivots by finding a cluster and then selecting the best point within that cluster based on mimicry pivoting strategy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.TreeMimicryPivotingFunctor-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}" href="#AdaptiveCrossApproximation.TreeMimicryPivotingFunctor-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F&lt;:Real}"><code>AdaptiveCrossApproximation.TreeMimicryPivotingFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::TreeMimicryPivotingFunctor)()</code></pre><p>Select the first pivot by locating a promising leaf cluster and choosing the point within that cluster that is closest to the reference centroid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ValuePivStrat" href="#AdaptiveCrossApproximation.ValuePivStrat"><code>AdaptiveCrossApproximation.ValuePivStrat</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValuePivStrat &lt;: PivStrat</code></pre><p>Abstract type for value-based pivoting strategies.</p><p>These strategies select pivots based on matrix element values sampled during the ACA algorithm. Most common approach for general matrices.</p><p><strong>Concrete Types</strong></p><ul><li><a href="#AdaptiveCrossApproximation.MaximumValue"><code>MaximumValue</code></a>: Selects index with maximum absolute value (standard ACA)</li><li><a href="#AdaptiveCrossApproximation.RandomSampling"><code>RandomSampling</code></a>: Random selection (for statistical approaches)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L59-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.ValuePivStratFunctor" href="#AdaptiveCrossApproximation.ValuePivStratFunctor"><code>AdaptiveCrossApproximation.ValuePivStratFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ValuePivStratFunctor &lt;: PivStratFunctor</code></pre><p>Abstract type for stateful value-based pivoting functors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/abstractpivoting.jl#L102-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA" href="#AdaptiveCrossApproximation.iACA"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">iACA{RowPivType,ColPivType,ConvCritType}</code></pre><p>Incomplete Adaptive Cross Approximation (iACA) compressor.</p><p>Unlike standard ACA, iACA computes only half of the factorization. It uses geometric pivoting strategies (e.g., mimicry or tree mimicry) to select row or column pivots based solely on spatial information, making it super efficient for hierarchical matrix construction where only row or column samples are requiered.</p><p><strong>Fields</strong></p><ul><li><code>rowpivoting::RowPivType</code>: Strategy for selecting row pivots (geometric)</li><li><code>columnpivoting::ColPivType</code>: Strategy for selecting column pivots</li><li><code>convergence::ConvCritType</code>: Convergence criterion</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L1-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64}} where {RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:TreeMimicryPivoting, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64}} where {RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:TreeMimicryPivoting, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{ValuePivStrat,TreeMimicryPivoting,ConvCrit})(rows, Ft, maxrank)</code></pre><p>Initialize iACA functor for tree-based column pivoting. For hierarchical matrices where column selection uses tree-aware mimicry.</p><p><strong>Arguments</strong></p><ul><li><code>rows::AbstractVector{Int}</code>: Row indices</li><li><code>Ft::AbstractVector{Int}</code>: Tree structure for column pivoting</li><li><code>maxrank::Int</code>: Maximum rank for approximation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L250-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64}} where {RowPivType&lt;:TreeMimicryPivoting, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}, Int64}} where {RowPivType&lt;:TreeMimicryPivoting, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{TreeMimicryPivoting,ValuePivStrat,ConvCrit})(Ft, cols, maxrank)</code></pre><p>Initialize iACA functor for tree-based row pivoting. For hierarchical matrices where row selection uses tree-aware mimicry.</p><p><strong>Arguments</strong></p><ul><li><code>Ft::AbstractVector{Int}</code>: Tree structure for row pivoting</li><li><code>cols::AbstractVector{Int}</code>: Column indices</li><li><code>maxrank::Int</code>: Maximum rank for approximation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L68-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}} where {RowPivType&lt;:AdaptiveCrossApproximation.GeoPivStrat, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}} where {RowPivType&lt;:AdaptiveCrossApproximation.GeoPivStrat, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{GeoPivStrat,ValuePivStrat,ConvCrit})(rows, cols)</code></pre><p>Initialize iACA functor for row matrix compression with geometric row pivoting. Creates functors for geometric row pivoting and value-based column pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>rows::AbstractVector{Int}</code>: Row indices for geometric pivoting</li><li><code>cols::AbstractVector{Int}</code>: Column indices for geometric pivoting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L51-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}} where {RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:AdaptiveCrossApproximation.GeoPivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{AbstractVector{Int64}, AbstractVector{Int64}}} where {RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:AdaptiveCrossApproximation.GeoPivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{ValuePivStrat,GeoPivStrat,ConvCrit})(rows, cols)</code></pre><p>Initialize iACA functor for column matrix compression with geometric column pivoting. Creates functors for value-based row pivoting and geometric column pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>rows::AbstractVector{Int}</code>: Row indices</li><li><code>cols::AbstractVector{Int}</code>: Column indices for geometric pivoting</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L233-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:MimicryPivoting, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:MimicryPivoting, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{ValuePivStrat,MimicryPivoting,ConvCrit})(A, rowbuffer, colbuffer, maxrank; kwargs...)</code></pre><p>Convenience method delegating to main computational routine for mimicry-based column pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>rowbuffer::AbstractArray{K}</code>: Buffer for row data</li><li><code>colbuffer::AbstractArray{K}</code>: Buffer for column data</li><li><code>maxrank::Int</code>: Maximum rank</li><li><code>rows</code>: Row indices (optional keyword)</li><li><code>cols</code>: Column indices (optional keyword)</li><li><code>rowidcs</code>: Row index range (optional keyword)</li><li><code>colidcs</code>: Column index range (optional keyword)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L270-L285">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:TreeMimicryPivoting, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ColPivType&lt;:TreeMimicryPivoting, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{ValuePivStrat,TreeMimicryPivoting,ConvCrit})(A, rowbuffer, colbuffer, maxrank; kwargs...)</code></pre><p>Convenience method delegating to main computational routine for tree-based column pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>rowbuffer::AbstractArray{K}</code>: Buffer for row data</li><li><code>colbuffer::AbstractArray{K}</code>: Buffer for column data</li><li><code>maxrank::Int</code>: Maximum rank</li><li><code>rows</code>: Row indices (optional keyword)</li><li><code>cols</code>: Column indices (optional keyword)</li><li><code>rowidcs</code>: Row index range (optional keyword)</li><li><code>colidcs</code>: Column index range (optional keyword)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L299-L314">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RowPivType&lt;:MimicryPivoting, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RowPivType&lt;:MimicryPivoting, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{MimicryPivoting,ValuePivStrat,ConvCrit})(A, colbuffer, rowbuffer, maxrank; kwargs...)</code></pre><p>Convenience method delegating to main computational routine for mimicry-based row pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>colbuffer::AbstractMatrix{K}</code>: Buffer for column data</li><li><code>rowbuffer::AbstractMatrix{K}</code>: Buffer for row data</li><li><code>maxrank::Int</code>: Maximum rank</li><li><code>rows</code>: Row indices (optional keyword)</li><li><code>cols</code>: Column indices (optional keyword)</li><li><code>rowidcs</code>: Row index range (optional keyword)</li><li><code>colidcs</code>: Column index range (optional keyword)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L88-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RowPivType&lt;:TreeMimicryPivoting, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64}} where {K, RowPivType&lt;:TreeMimicryPivoting, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStrat, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCrit}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{TreeMimicryPivoting,ValuePivStrat,ConvCrit})(A, colbuffer, rowbuffer, maxrank; kwargs...)</code></pre><p>Convenience method delegating to main computational routine for tree-based row pivoting.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>colbuffer::AbstractMatrix{K}</code>: Buffer for column data</li><li><code>rowbuffer::AbstractMatrix{K}</code>: Buffer for row data</li><li><code>maxrank::Int</code>: Maximum rank</li><li><code>rows</code>: Row indices (optional keyword)</li><li><code>cols</code>: Column indices (optional keyword)</li><li><code>rowidcs</code>: Row index range (optional keyword)</li><li><code>colidcs</code>: Column index range (optional keyword)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L117-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{F}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, F}, 1}, Array{StaticArraysCore.SVector{D, F}, 1}}} where {D, F&lt;:Real}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{F}, Tuple{D}, Tuple{Array{StaticArraysCore.SVector{D, F}, 1}, Array{StaticArraysCore.SVector{D, F}, 1}}} where {D, F&lt;:Real}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iACA(tpos::Vector{SVector{D,F}}, spos::Vector{SVector{D,F}})</code></pre><p>Construct an iACA compressor with default settings for geometric pivoting.</p><p>Creates an iACA using maximum value for row pivoting, mimicry pivoting for columns (mimicking the spatial distribution of a fully pivoting when selecting from <code>spos</code>), and Frobenius norm extrapolation for convergence.</p><p><strong>Arguments</strong></p><ul><li><code>tpos</code>: Test/target point positions (reference distribution)</li><li><code>spos</code>: Source point positions (candidates for selection)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L29-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{T}, Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64, T, T, T}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStratFunctor, ColPivType&lt;:AdaptiveCrossApproximation.GeoPivStratFunctor, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCritFunctor, T&lt;:Vector{Int64}}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{T}, Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractArray{K}, AbstractArray{K}, Int64, T, T, T}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.ValuePivStratFunctor, ColPivType&lt;:AdaptiveCrossApproximation.GeoPivStratFunctor, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCritFunctor, T&lt;:Vector{Int64}}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{ValuePivStratFunctor,GeoPivStratFunctor,ConvCritFunctor})(A, colbuffer, rowbuffer, maxrank, rows, cols, rowidcs)</code></pre><p>Main computational routine for column matrix iACA (value-based row pivoting, geometric column pivoting). Performs incomplete ACA compression where columns are selected geometrically and rows by maximum value.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>colbuffer::AbstractArray{K}</code>: Buffer for column data</li><li><code>rowbuffer::AbstractArray{K}</code>: Buffer for row data</li><li><code>maxrank::Int</code>: Maximum rank</li><li><code>rows::Vector{Int}</code>: Row indices storage</li><li><code>cols::Vector{Int}</code>: Column indices storage</li><li><code>rowidcs::Vector{Int}</code>: Row index range</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Number of pivots computed</li><li><code>rows::Vector{Int}</code>: Selected row indices (global)</li><li><code>cols::Vector{Int}</code>: Selected column indices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L330-L351">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iACA-Union{Tuple{T}, Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64, T, T, T}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.GeoPivStratFunctor, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStratFunctor, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCritFunctor, T&lt;:Vector{Int64}}" href="#AdaptiveCrossApproximation.iACA-Union{Tuple{T}, Tuple{ConvCritType}, Tuple{ColPivType}, Tuple{RowPivType}, Tuple{K}, Tuple{Any, AbstractMatrix{K}, AbstractMatrix{K}, Int64, T, T, T}} where {K, RowPivType&lt;:AdaptiveCrossApproximation.GeoPivStratFunctor, ColPivType&lt;:AdaptiveCrossApproximation.ValuePivStratFunctor, ConvCritType&lt;:AdaptiveCrossApproximation.ConvCritFunctor, T&lt;:Vector{Int64}}"><code>AdaptiveCrossApproximation.iACA</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(iaca::iACA{GeoPivStratFunctor,ValuePivStratFunctor,ConvCritFunctor})(A, colbuffer, rowbuffer, maxrank, rows, cols, colidcs)</code></pre><p>Main computational routine for row matrix iACA (geometric row pivoting, value-based column pivoting). Performs incomplete ACA compression where rows are selected geometrically and columns by maximum value.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Matrix to compress</li><li><code>colbuffer::AbstractMatrix{K}</code>: Buffer for column data</li><li><code>rowbuffer::AbstractMatrix{K}</code>: Buffer for row data</li><li><code>maxrank::Int</code>: Maximum rank</li><li><code>rows::Vector{Int}</code>: Row indices storage</li><li><code>cols::Vector{Int}</code>: Column indices storage</li><li><code>colidcs::Vector{Int}</code>: Column index range</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Number of pivots computed</li><li><code>rows::Vector{Int}</code>: Selected row indices</li><li><code>cols::Vector{Int}</code>: Selected column indices (global)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/iaca.jl#L148-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iFNormEstimator" href="#AdaptiveCrossApproximation.iFNormEstimator"><code>AdaptiveCrossApproximation.iFNormEstimator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">iFNormEstimator{F} &lt;: ConvCrit</code></pre><p>Frobenius norm-based convergence criterion for incomplete ACA (iACA). Uses moving average norm estimate for geometric pivoting scenarios.</p><p><strong>Fields</strong></p><ul><li><code>tol::F</code>: Relative tolerance threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iFNormEstimator-Union{Tuple{}, Tuple{F}} where F" href="#AdaptiveCrossApproximation.iFNormEstimator-Union{Tuple{}, Tuple{F}} where F"><code>AdaptiveCrossApproximation.iFNormEstimator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(cc::iFNormEstimator{F})()</code></pre><p>Initialize iFNormEstimator functor with zero accumulated norm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iFNormEstimatorFunctor" href="#AdaptiveCrossApproximation.iFNormEstimatorFunctor"><code>AdaptiveCrossApproximation.iFNormEstimatorFunctor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">iFNormEstimatorFunctor{F} &lt;: ConvCritFunctor</code></pre><p>Stateful Frobenius norm estimator for iACA compression. Tracks moving average of row/column norms.</p><p><strong>Fields</strong></p><ul><li><code>normUV::F</code>: Moving average norm</li><li><code>tol::F</code>: Relative tolerance threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.iFNormEstimatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractVector{K}, Int64}} where {F&lt;:Real, K}" href="#AdaptiveCrossApproximation.iFNormEstimatorFunctor-Union{Tuple{K}, Tuple{F}, Tuple{AbstractVector{K}, Int64}} where {F&lt;:Real, K}"><code>AdaptiveCrossApproximation.iFNormEstimatorFunctor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(convcrit::iFNormEstimatorFunctor)(rcbuffer::AbstractVector{K}, npivot::Int)</code></pre><p>Check convergence for iACA using moving average norm. Returns (npivot, continue) where continue is true if iteration should proceed.</p><p><strong>Arguments</strong></p><ul><li><code>rcbuffer::AbstractVector{K}</code>: Current row or column buffer</li><li><code>npivot::Int</code>: Current pivot index</li></ul><p><strong>Returns</strong></p><ul><li><code>npivot::Int</code>: Final pivot count</li><li><code>continue::Bool</code>: Whether to continue iteration</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L129-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Core.Union-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F}" href="#Core.Union-Union{Tuple{}, Tuple{F}, Tuple{D}} where {D, F}"><code>Core.Union</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(pivstrat::Union{Leja2Functor{D,F},FillDistanceFunctor{D,F}})()</code></pre><p>Select the first point as the initial pivot.</p><p>Computes distances from all points to the first point and returns index 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/filldistance.jl#L61-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.aca-Union{Tuple{AbstractMatrix{K}}, Tuple{K}} where K" href="#AdaptiveCrossApproximation.aca-Union{Tuple{AbstractMatrix{K}}, Tuple{K}} where K"><code>AdaptiveCrossApproximation.aca</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aca(M; tol=1e-4, rowpivoting=MaximumValue(), columnpivoting=MaximumValue(),
    convergence=FNormEstimator(tol), maxrank=40, svdrecompress=false)</code></pre><p>Compute adaptive cross approximation of matrix <code>M</code> returning low-rank factors.</p><p>High-level convenience function that automatically allocates buffers and returns <code>U, V</code> such that <code>M ≈ U * V</code>.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix{K}</code>: Matrix to approximate</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tol::Real = 1e-4</code>: Approximation tolerance</li><li><code>rowpivoting = MaximumValue()</code>: Row pivot selection strategy</li><li><code>columnpivoting = MaximumValue()</code>: Column pivot selection strategy</li><li><code>convergence = FNormEstimator(tol)</code>: Convergence criterion</li><li><code>maxrank::Int = 40</code>: Maximum rank (hard limit)</li><li><code>svdrecompress::Bool = false</code>: Apply SVD-based recompression to reduce rank further</li></ul><p><strong>Returns</strong></p><ul><li><code>U::Matrix{K}</code>: Left factor, size <code>(size(M,1), r)</code> where <code>r ≤ maxrank</code></li><li><code>V::Matrix{K}</code>: Right factor, size <code>(r, size(M,2))</code></li></ul><p>Satisfies <code>M ≈ U * V</code> with <code>norm(M - U*V) / norm(M) ≲ tol</code> (if maxrank sufficient).</p><p><strong>SVD Recompression</strong></p><p>When <code>svdrecompress=true</code>, performs QR-SVD recompression: computes <code>M ≈ U*V</code>, then <code>U = Q*R</code>, <code>R*V = Û*Σ*V̂ᵀ</code>, truncates small singular values, and returns optimal rank factors at the cost of additional computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L248-L282">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.acaᵀ-Union{Tuple{AbstractMatrix{K}}, Tuple{K}} where K" href="#AdaptiveCrossApproximation.acaᵀ-Union{Tuple{AbstractMatrix{K}}, Tuple{K}} where K"><code>AdaptiveCrossApproximation.acaᵀ</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acaᵀ(M; tol=1e-4, rowpivoting, columnpivoting, convergence, maxrank=40)</code></pre><p>Convenience function for column-first ACA compression. Automatically allocates buffers and performs compression.</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix{K}</code>: Matrix to compress</li><li><code>tol</code>: Convergence tolerance (default: <code>1e-4</code>)</li><li><code>rowpivoting</code>: Row pivoting strategy (default: <code>MaximumValueFunctor</code>)</li><li><code>columnpivoting</code>: Column pivoting strategy (default: <code>MaximumValueFunctor</code>)</li><li><code>convergence</code>: Convergence criterion (default: <code>FNormEstimator(0.0, tol)</code>)</li><li><code>maxrank</code>: Maximum rank (default: <code>40</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>colbuffer</code>: Column factor (nrows × npivots)</li><li><code>rowbuffer</code>: Row factor (npivots × ncols)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/acaT.jl#L183-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.findcluster-Union{Tuple{I}, Tuple{T}, Tuple{D}, Tuple{AdaptiveCrossApproximation.TreeMimicryPivotingFunctor{D, T}, Vector{I}, I}} where {D, T&lt;:Real, I}" href="#AdaptiveCrossApproximation.findcluster-Union{Tuple{I}, Tuple{T}, Tuple{D}, Tuple{AdaptiveCrossApproximation.TreeMimicryPivotingFunctor{D, T}, Vector{I}, I}} where {D, T&lt;:Real, I}"><code>AdaptiveCrossApproximation.findcluster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findcluster(pivstrat, F, npivot)</code></pre><p>Cluster-based selection used during later pivot iterations.</p><p>For each candidate cluster <code>f</code> in <code>F</code>, compute a composite score combining Leja products, fill distances and inverse-distance weights to the reference centroid; select the cluster maximizing this score and recurse until a leaf is reached.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L118-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.findcluster-Union{Tuple{I}, Tuple{T}, Tuple{D}, Tuple{AdaptiveCrossApproximation.TreeMimicryPivotingFunctor{D, T}, Vector{I}}} where {D, T&lt;:Real, I}" href="#AdaptiveCrossApproximation.findcluster-Union{Tuple{I}, Tuple{T}, Tuple{D}, Tuple{AdaptiveCrossApproximation.TreeMimicryPivotingFunctor{D, T}, Vector{I}}} where {D, T&lt;:Real, I}"><code>AdaptiveCrossApproximation.findcluster</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">findcluster(pivstrat, F)</code></pre><p>Find a leaf cluster (node) that best matches the reference centroid.</p><p>Traverses the tree greedily by choosing child clusters whose centers are closest (in weighted inverse-distance sense) to the reference centroid <code>pivstrat.c</code>. Returns a node index whose <code>firstchild</code> is zero (leaf) or recurses into children.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/treemimicrypivoting.jl#L97-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.leja2!-Tuple{AdaptiveCrossApproximation.GeoPivStratFunctor, Int64}" href="#AdaptiveCrossApproximation.leja2!-Tuple{AdaptiveCrossApproximation.GeoPivStratFunctor, Int64}"><code>AdaptiveCrossApproximation.leja2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">leja2!(pivstrat::GeoPivStratFunctor, nextidx::Int)</code></pre><p>Update minimum distances after selecting pivot <code>nextidx</code>.</p><p>Computes distances from all points to the newly selected pivot and updates the minimum distance vector <code>h</code> by taking element-wise minimum with new distances. This shared helper is used by both Leja2 and fill distance strategies.</p><p><strong>Arguments</strong></p><ul><li><code>pivstrat::GeoPivStratFunctor</code>: Functor with distance vector to update</li><li><code>nextidx::Int</code>: Index of newly selected pivot</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/pivoting/lejapoints.jl#L65-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.nextrc!-Tuple{Any, AbstractArray, Any, Any}" href="#AdaptiveCrossApproximation.nextrc!-Tuple{Any, AbstractArray, Any, Any}"><code>AdaptiveCrossApproximation.nextrc!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nextrc!(buf, A::AbstractArray, i, j)</code></pre><p>Fill buffer <code>buf</code> with submatrix <code>A[i, j]</code>.</p><p>Internal utility for matrix element access. Can be extended for custom matrix types to enable ACA compression of matrix-free operators.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/aca.jl#L93-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.normF!-Union{Tuple{K}, Tuple{AdaptiveCrossApproximation.ConvCritFunctor, AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where K" href="#AdaptiveCrossApproximation.normF!-Union{Tuple{K}, Tuple{AdaptiveCrossApproximation.ConvCritFunctor, AbstractMatrix{K}, AbstractMatrix{K}, Int64, Int64, Int64}} where K"><code>AdaptiveCrossApproximation.normF!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normF!(convcrit::ConvCritFunctor, rowbuffer, colbuffer, npivot, maxrows, maxcolumns)</code></pre><p>Update Frobenius norm estimate for standard ACA. Incrementally computes squared norm of UV factorization using current pivot and all previous pivots.</p><p><strong>Arguments</strong></p><ul><li><code>convcrit::ConvCritFunctor</code>: Convergence criterion functor to update</li><li><code>rowbuffer::AbstractMatrix{K}</code>: Row factor buffer</li><li><code>colbuffer::AbstractMatrix{K}</code>: Column factor buffer</li><li><code>npivot::Int</code>: Current pivot index</li><li><code>maxrows::Int</code>: Number of active rows</li><li><code>maxcolumns::Int</code>: Number of active columns</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/abstractconvergence.jl#L17-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.normF!-Union{Tuple{K}, Tuple{AdaptiveCrossApproximation.ConvCritFunctor, AbstractVector{K}, Int64}} where K" href="#AdaptiveCrossApproximation.normF!-Union{Tuple{K}, Tuple{AdaptiveCrossApproximation.ConvCritFunctor, AbstractVector{K}, Int64}} where K"><code>AdaptiveCrossApproximation.normF!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">normF!(convcrit::ConvCritFunctor, rcbuffer::AbstractVector{K}, npivot::Int)</code></pre><p>Update running norm estimate for incomplete ACA (iACA). Computes moving average of row/column norms across pivots.</p><p><strong>Arguments</strong></p><ul><li><code>convcrit::ConvCritFunctor</code>: Convergence criterion functor to update</li><li><code>rcbuffer::AbstractVector{K}</code>: Current row or column buffer</li><li><code>npivot::Int</code>: Current pivot index</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/abstractconvergence.jl#L52-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.FNormExtrapolatorFunctor}" href="#AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.FNormExtrapolatorFunctor}"><code>AdaptiveCrossApproximation.tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tolerance(cc::FNormExtrapolatorFunctor)</code></pre><p>Get tolerance from underlying estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/extrapolation.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.RandomSamplingFunctor}" href="#AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.RandomSamplingFunctor}"><code>AdaptiveCrossApproximation.tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tolerance(cc::RandomSamplingFunctor)</code></pre><p>Get tolerance from random sampling functor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/randomsampling.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.iFNormEstimatorFunctor}" href="#AdaptiveCrossApproximation.tolerance-Tuple{AdaptiveCrossApproximation.iFNormEstimatorFunctor}"><code>AdaptiveCrossApproximation.tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tolerance(cc::iFNormEstimatorFunctor)</code></pre><p>Get tolerance threshold from iACA estimator functor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AdaptiveCrossApproximation.tolerance-Tuple{FNormEstimator}" href="#AdaptiveCrossApproximation.tolerance-Tuple{FNormEstimator}"><code>AdaptiveCrossApproximation.tolerance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tolerance(cc::FNormEstimator)</code></pre><p>Get tolerance threshold from estimator.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JoshuaTetzner/AdaptiveCrossApproximation.jl/blob/5aeb1a81a5a50c346ccc6c4ec1697243099734ac/src/convergence/estimation.jl#L39-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../contributing/">« Contributing</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 17 November 2025 13:31">Monday 17 November 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
